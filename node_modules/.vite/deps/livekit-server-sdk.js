import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick((function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }).bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer2 = require_buffer().Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", (function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }).bind(this));
      this.payload.once("close", (function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }).bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", (function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }).bind(this));
      this.signature.once("close", (function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }).bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/semver/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/semver/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/semver/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/semver/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key)
        return;
      const keyType = key.asymmetricKeyType;
      if (!keyType)
        return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require_crypto();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require_crypto();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/livekit-server-sdk/dist/AccessToken.js
var require_AccessToken = __commonJS({
  "node_modules/livekit-server-sdk/dist/AccessToken.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenVerifier = exports2.AccessToken = void 0;
    var jwt = __importStar(require_jsonwebtoken());
    var defaultTTL = 6 * 60 * 60;
    var AccessToken = class {
      /**
       * Creates a new AccessToken
       * @param apiKey API Key, can be set in env LIVEKIT_API_KEY
       * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET
       */
      constructor(apiKey, apiSecret, options) {
        if (!apiKey) {
          apiKey = process.env.LIVEKIT_API_KEY;
        }
        if (!apiSecret) {
          apiSecret = process.env.LIVEKIT_API_SECRET;
        }
        if (!apiKey || !apiSecret) {
          throw Error("api-key and api-secret must be set");
        } else if (typeof document !== "undefined") {
          console.error("You should not include your API secret in your web client bundle.\n\nYour web client should request a token from your backend server which should then use the API secret to generate a token. See https://docs.livekit.io/client/connect/");
        }
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.grants = {};
        this.identity = options === null || options === void 0 ? void 0 : options.identity;
        this.ttl = (options === null || options === void 0 ? void 0 : options.ttl) || defaultTTL;
        if (options === null || options === void 0 ? void 0 : options.metadata) {
          this.metadata = options.metadata;
        }
        if (options === null || options === void 0 ? void 0 : options.name) {
          this.name = options.name;
        }
      }
      /**
       * Adds a video grant to this token.
       * @param grant
       */
      addGrant(grant) {
        this.grants.video = grant;
      }
      /**
       * Set metadata to be passed to the Participant, used only when joining the room
       */
      set metadata(md) {
        this.grants.metadata = md;
      }
      set name(name) {
        this.grants.name = name;
      }
      get sha256() {
        return this.grants.sha256;
      }
      set sha256(sha) {
        this.grants.sha256 = sha;
      }
      /**
       * @returns JWT encoded token
       */
      toJwt() {
        var _a;
        const opts = {
          issuer: this.apiKey,
          expiresIn: this.ttl,
          notBefore: 0
        };
        if (this.identity) {
          opts.subject = this.identity;
          opts.jwtid = this.identity;
        } else if ((_a = this.grants.video) === null || _a === void 0 ? void 0 : _a.roomJoin) {
          throw Error("identity is required for join but not set");
        }
        return jwt.sign(this.grants, this.apiSecret, opts);
      }
    };
    exports2.AccessToken = AccessToken;
    var TokenVerifier = class {
      constructor(apiKey, apiSecret) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
      }
      verify(token) {
        const decoded = jwt.verify(token, this.apiSecret, { issuer: this.apiKey });
        if (!decoded) {
          throw Error("invalid token");
        }
        return decoded;
      }
    };
    exports2.TokenVerifier = TokenVerifier;
  }
});

// node_modules/long/umd/index.js
var require_umd = __commonJS({
  "node_modules/long/umd/index.js"(exports2, module2) {
    var Long = function(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", {
        value: true
      });
      exports3.default = void 0;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (e) {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return this;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero())
          return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32)
          return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      var _default = Long2;
      exports3.default = _default;
      return "default" in exports3 ? exports3.default : exports3;
    }({});
    if (typeof define === "function" && define.amd)
      define([], function() {
        return Long;
      });
    else if (typeof module2 === "object" && typeof exports2 === "object")
      module2.exports = Long;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/livekit-server-sdk/dist/proto/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/livekit-server-sdk/dist/proto/google/protobuf/timestamp.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_umd());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return { seconds: 0, nanos: 0 };
    }
    exports2.Timestamp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== 0) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = longToNumber(reader.int64());
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          seconds: isSet(object.seconds) ? Number(object.seconds) : 0,
          nanos: isSet(object.nanos) ? Number(object.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = Math.round(message.seconds));
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTimestamp();
        message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : 0;
        message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function longToNumber(long) {
      if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
      }
      return long.toNumber();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/livekit-server-sdk/dist/proto/livekit_models.js
var require_livekit_models = __commonJS({
  "node_modules/livekit-server-sdk/dist/proto/livekit_models.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParticipantPermission = exports2.PlayoutDelay = exports2.Codec = exports2.Room = exports2.clientInfo_SDKToJSON = exports2.clientInfo_SDKFromJSON = exports2.ClientInfo_SDK = exports2.serverInfo_EditionToJSON = exports2.serverInfo_EditionFromJSON = exports2.ServerInfo_Edition = exports2.dataPacket_KindToJSON = exports2.dataPacket_KindFromJSON = exports2.DataPacket_Kind = exports2.encryption_TypeToJSON = exports2.encryption_TypeFromJSON = exports2.Encryption_Type = exports2.participantInfo_StateToJSON = exports2.participantInfo_StateFromJSON = exports2.ParticipantInfo_State = exports2.subscriptionErrorToJSON = exports2.subscriptionErrorFromJSON = exports2.SubscriptionError = exports2.reconnectReasonToJSON = exports2.reconnectReasonFromJSON = exports2.ReconnectReason = exports2.disconnectReasonToJSON = exports2.disconnectReasonFromJSON = exports2.DisconnectReason = exports2.clientConfigSettingToJSON = exports2.clientConfigSettingFromJSON = exports2.ClientConfigSetting = exports2.connectionQualityToJSON = exports2.connectionQualityFromJSON = exports2.ConnectionQuality = exports2.videoQualityToJSON = exports2.videoQualityFromJSON = exports2.VideoQuality = exports2.trackSourceToJSON = exports2.trackSourceFromJSON = exports2.TrackSource = exports2.trackTypeToJSON = exports2.trackTypeFromJSON = exports2.TrackType = exports2.videoCodecToJSON = exports2.videoCodecFromJSON = exports2.VideoCodec = exports2.audioCodecToJSON = exports2.audioCodecFromJSON = exports2.AudioCodec = exports2.protobufPackage = void 0;
    exports2.TimedVersion = exports2.RTPStats_GapHistogramEntry = exports2.RTPStats = exports2.DisabledCodecs = exports2.VideoConfiguration = exports2.ClientConfiguration = exports2.ClientInfo = exports2.ServerInfo = exports2.ParticipantTracks = exports2.UserPacket = exports2.SpeakerInfo = exports2.ActiveSpeakerUpdate = exports2.DataPacket = exports2.VideoLayer = exports2.TrackInfo = exports2.SimulcastCodecInfo = exports2.Encryption = exports2.ParticipantInfo = void 0;
    var long_1 = __importDefault(require_umd());
    var minimal_1 = __importDefault(require_minimal2());
    var timestamp_1 = require_timestamp();
    exports2.protobufPackage = "livekit";
    var AudioCodec;
    (function(AudioCodec2) {
      AudioCodec2[AudioCodec2["DEFAULT_AC"] = 0] = "DEFAULT_AC";
      AudioCodec2[AudioCodec2["OPUS"] = 1] = "OPUS";
      AudioCodec2[AudioCodec2["AAC"] = 2] = "AAC";
      AudioCodec2[AudioCodec2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AudioCodec = exports2.AudioCodec || (exports2.AudioCodec = {}));
    function audioCodecFromJSON(object) {
      switch (object) {
        case 0:
        case "DEFAULT_AC":
          return AudioCodec.DEFAULT_AC;
        case 1:
        case "OPUS":
          return AudioCodec.OPUS;
        case 2:
        case "AAC":
          return AudioCodec.AAC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AudioCodec.UNRECOGNIZED;
      }
    }
    exports2.audioCodecFromJSON = audioCodecFromJSON;
    function audioCodecToJSON(object) {
      switch (object) {
        case AudioCodec.DEFAULT_AC:
          return "DEFAULT_AC";
        case AudioCodec.OPUS:
          return "OPUS";
        case AudioCodec.AAC:
          return "AAC";
        case AudioCodec.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.audioCodecToJSON = audioCodecToJSON;
    var VideoCodec;
    (function(VideoCodec2) {
      VideoCodec2[VideoCodec2["DEFAULT_VC"] = 0] = "DEFAULT_VC";
      VideoCodec2[VideoCodec2["H264_BASELINE"] = 1] = "H264_BASELINE";
      VideoCodec2[VideoCodec2["H264_MAIN"] = 2] = "H264_MAIN";
      VideoCodec2[VideoCodec2["H264_HIGH"] = 3] = "H264_HIGH";
      VideoCodec2[VideoCodec2["VP8"] = 4] = "VP8";
      VideoCodec2[VideoCodec2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VideoCodec = exports2.VideoCodec || (exports2.VideoCodec = {}));
    function videoCodecFromJSON(object) {
      switch (object) {
        case 0:
        case "DEFAULT_VC":
          return VideoCodec.DEFAULT_VC;
        case 1:
        case "H264_BASELINE":
          return VideoCodec.H264_BASELINE;
        case 2:
        case "H264_MAIN":
          return VideoCodec.H264_MAIN;
        case 3:
        case "H264_HIGH":
          return VideoCodec.H264_HIGH;
        case 4:
        case "VP8":
          return VideoCodec.VP8;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VideoCodec.UNRECOGNIZED;
      }
    }
    exports2.videoCodecFromJSON = videoCodecFromJSON;
    function videoCodecToJSON(object) {
      switch (object) {
        case VideoCodec.DEFAULT_VC:
          return "DEFAULT_VC";
        case VideoCodec.H264_BASELINE:
          return "H264_BASELINE";
        case VideoCodec.H264_MAIN:
          return "H264_MAIN";
        case VideoCodec.H264_HIGH:
          return "H264_HIGH";
        case VideoCodec.VP8:
          return "VP8";
        case VideoCodec.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.videoCodecToJSON = videoCodecToJSON;
    var TrackType;
    (function(TrackType2) {
      TrackType2[TrackType2["AUDIO"] = 0] = "AUDIO";
      TrackType2[TrackType2["VIDEO"] = 1] = "VIDEO";
      TrackType2[TrackType2["DATA"] = 2] = "DATA";
      TrackType2[TrackType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TrackType = exports2.TrackType || (exports2.TrackType = {}));
    function trackTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "AUDIO":
          return TrackType.AUDIO;
        case 1:
        case "VIDEO":
          return TrackType.VIDEO;
        case 2:
        case "DATA":
          return TrackType.DATA;
        case -1:
        case "UNRECOGNIZED":
        default:
          return TrackType.UNRECOGNIZED;
      }
    }
    exports2.trackTypeFromJSON = trackTypeFromJSON;
    function trackTypeToJSON(object) {
      switch (object) {
        case TrackType.AUDIO:
          return "AUDIO";
        case TrackType.VIDEO:
          return "VIDEO";
        case TrackType.DATA:
          return "DATA";
        case TrackType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.trackTypeToJSON = trackTypeToJSON;
    var TrackSource;
    (function(TrackSource2) {
      TrackSource2[TrackSource2["UNKNOWN"] = 0] = "UNKNOWN";
      TrackSource2[TrackSource2["CAMERA"] = 1] = "CAMERA";
      TrackSource2[TrackSource2["MICROPHONE"] = 2] = "MICROPHONE";
      TrackSource2[TrackSource2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
      TrackSource2[TrackSource2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
      TrackSource2[TrackSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TrackSource = exports2.TrackSource || (exports2.TrackSource = {}));
    function trackSourceFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return TrackSource.UNKNOWN;
        case 1:
        case "CAMERA":
          return TrackSource.CAMERA;
        case 2:
        case "MICROPHONE":
          return TrackSource.MICROPHONE;
        case 3:
        case "SCREEN_SHARE":
          return TrackSource.SCREEN_SHARE;
        case 4:
        case "SCREEN_SHARE_AUDIO":
          return TrackSource.SCREEN_SHARE_AUDIO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return TrackSource.UNRECOGNIZED;
      }
    }
    exports2.trackSourceFromJSON = trackSourceFromJSON;
    function trackSourceToJSON(object) {
      switch (object) {
        case TrackSource.UNKNOWN:
          return "UNKNOWN";
        case TrackSource.CAMERA:
          return "CAMERA";
        case TrackSource.MICROPHONE:
          return "MICROPHONE";
        case TrackSource.SCREEN_SHARE:
          return "SCREEN_SHARE";
        case TrackSource.SCREEN_SHARE_AUDIO:
          return "SCREEN_SHARE_AUDIO";
        case TrackSource.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.trackSourceToJSON = trackSourceToJSON;
    var VideoQuality;
    (function(VideoQuality2) {
      VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
      VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
      VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
      VideoQuality2[VideoQuality2["OFF"] = 3] = "OFF";
      VideoQuality2[VideoQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VideoQuality = exports2.VideoQuality || (exports2.VideoQuality = {}));
    function videoQualityFromJSON(object) {
      switch (object) {
        case 0:
        case "LOW":
          return VideoQuality.LOW;
        case 1:
        case "MEDIUM":
          return VideoQuality.MEDIUM;
        case 2:
        case "HIGH":
          return VideoQuality.HIGH;
        case 3:
        case "OFF":
          return VideoQuality.OFF;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VideoQuality.UNRECOGNIZED;
      }
    }
    exports2.videoQualityFromJSON = videoQualityFromJSON;
    function videoQualityToJSON(object) {
      switch (object) {
        case VideoQuality.LOW:
          return "LOW";
        case VideoQuality.MEDIUM:
          return "MEDIUM";
        case VideoQuality.HIGH:
          return "HIGH";
        case VideoQuality.OFF:
          return "OFF";
        case VideoQuality.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.videoQualityToJSON = videoQualityToJSON;
    var ConnectionQuality;
    (function(ConnectionQuality2) {
      ConnectionQuality2[ConnectionQuality2["POOR"] = 0] = "POOR";
      ConnectionQuality2[ConnectionQuality2["GOOD"] = 1] = "GOOD";
      ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 2] = "EXCELLENT";
      ConnectionQuality2[ConnectionQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ConnectionQuality = exports2.ConnectionQuality || (exports2.ConnectionQuality = {}));
    function connectionQualityFromJSON(object) {
      switch (object) {
        case 0:
        case "POOR":
          return ConnectionQuality.POOR;
        case 1:
        case "GOOD":
          return ConnectionQuality.GOOD;
        case 2:
        case "EXCELLENT":
          return ConnectionQuality.EXCELLENT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ConnectionQuality.UNRECOGNIZED;
      }
    }
    exports2.connectionQualityFromJSON = connectionQualityFromJSON;
    function connectionQualityToJSON(object) {
      switch (object) {
        case ConnectionQuality.POOR:
          return "POOR";
        case ConnectionQuality.GOOD:
          return "GOOD";
        case ConnectionQuality.EXCELLENT:
          return "EXCELLENT";
        case ConnectionQuality.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.connectionQualityToJSON = connectionQualityToJSON;
    var ClientConfigSetting;
    (function(ClientConfigSetting2) {
      ClientConfigSetting2[ClientConfigSetting2["UNSET"] = 0] = "UNSET";
      ClientConfigSetting2[ClientConfigSetting2["DISABLED"] = 1] = "DISABLED";
      ClientConfigSetting2[ClientConfigSetting2["ENABLED"] = 2] = "ENABLED";
      ClientConfigSetting2[ClientConfigSetting2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ClientConfigSetting = exports2.ClientConfigSetting || (exports2.ClientConfigSetting = {}));
    function clientConfigSettingFromJSON(object) {
      switch (object) {
        case 0:
        case "UNSET":
          return ClientConfigSetting.UNSET;
        case 1:
        case "DISABLED":
          return ClientConfigSetting.DISABLED;
        case 2:
        case "ENABLED":
          return ClientConfigSetting.ENABLED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ClientConfigSetting.UNRECOGNIZED;
      }
    }
    exports2.clientConfigSettingFromJSON = clientConfigSettingFromJSON;
    function clientConfigSettingToJSON(object) {
      switch (object) {
        case ClientConfigSetting.UNSET:
          return "UNSET";
        case ClientConfigSetting.DISABLED:
          return "DISABLED";
        case ClientConfigSetting.ENABLED:
          return "ENABLED";
        case ClientConfigSetting.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.clientConfigSettingToJSON = clientConfigSettingToJSON;
    var DisconnectReason;
    (function(DisconnectReason2) {
      DisconnectReason2[DisconnectReason2["UNKNOWN_REASON"] = 0] = "UNKNOWN_REASON";
      DisconnectReason2[DisconnectReason2["CLIENT_INITIATED"] = 1] = "CLIENT_INITIATED";
      DisconnectReason2[DisconnectReason2["DUPLICATE_IDENTITY"] = 2] = "DUPLICATE_IDENTITY";
      DisconnectReason2[DisconnectReason2["SERVER_SHUTDOWN"] = 3] = "SERVER_SHUTDOWN";
      DisconnectReason2[DisconnectReason2["PARTICIPANT_REMOVED"] = 4] = "PARTICIPANT_REMOVED";
      DisconnectReason2[DisconnectReason2["ROOM_DELETED"] = 5] = "ROOM_DELETED";
      DisconnectReason2[DisconnectReason2["STATE_MISMATCH"] = 6] = "STATE_MISMATCH";
      DisconnectReason2[DisconnectReason2["JOIN_FAILURE"] = 7] = "JOIN_FAILURE";
      DisconnectReason2[DisconnectReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(DisconnectReason = exports2.DisconnectReason || (exports2.DisconnectReason = {}));
    function disconnectReasonFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN_REASON":
          return DisconnectReason.UNKNOWN_REASON;
        case 1:
        case "CLIENT_INITIATED":
          return DisconnectReason.CLIENT_INITIATED;
        case 2:
        case "DUPLICATE_IDENTITY":
          return DisconnectReason.DUPLICATE_IDENTITY;
        case 3:
        case "SERVER_SHUTDOWN":
          return DisconnectReason.SERVER_SHUTDOWN;
        case 4:
        case "PARTICIPANT_REMOVED":
          return DisconnectReason.PARTICIPANT_REMOVED;
        case 5:
        case "ROOM_DELETED":
          return DisconnectReason.ROOM_DELETED;
        case 6:
        case "STATE_MISMATCH":
          return DisconnectReason.STATE_MISMATCH;
        case 7:
        case "JOIN_FAILURE":
          return DisconnectReason.JOIN_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return DisconnectReason.UNRECOGNIZED;
      }
    }
    exports2.disconnectReasonFromJSON = disconnectReasonFromJSON;
    function disconnectReasonToJSON(object) {
      switch (object) {
        case DisconnectReason.UNKNOWN_REASON:
          return "UNKNOWN_REASON";
        case DisconnectReason.CLIENT_INITIATED:
          return "CLIENT_INITIATED";
        case DisconnectReason.DUPLICATE_IDENTITY:
          return "DUPLICATE_IDENTITY";
        case DisconnectReason.SERVER_SHUTDOWN:
          return "SERVER_SHUTDOWN";
        case DisconnectReason.PARTICIPANT_REMOVED:
          return "PARTICIPANT_REMOVED";
        case DisconnectReason.ROOM_DELETED:
          return "ROOM_DELETED";
        case DisconnectReason.STATE_MISMATCH:
          return "STATE_MISMATCH";
        case DisconnectReason.JOIN_FAILURE:
          return "JOIN_FAILURE";
        case DisconnectReason.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.disconnectReasonToJSON = disconnectReasonToJSON;
    var ReconnectReason;
    (function(ReconnectReason2) {
      ReconnectReason2[ReconnectReason2["RR_UNKNOWN"] = 0] = "RR_UNKNOWN";
      ReconnectReason2[ReconnectReason2["RR_SIGNAL_DISCONNECTED"] = 1] = "RR_SIGNAL_DISCONNECTED";
      ReconnectReason2[ReconnectReason2["RR_PUBLISHER_FAILED"] = 2] = "RR_PUBLISHER_FAILED";
      ReconnectReason2[ReconnectReason2["RR_SUBSCRIBER_FAILED"] = 3] = "RR_SUBSCRIBER_FAILED";
      ReconnectReason2[ReconnectReason2["RR_SWITCH_CANDIDATE"] = 4] = "RR_SWITCH_CANDIDATE";
      ReconnectReason2[ReconnectReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ReconnectReason = exports2.ReconnectReason || (exports2.ReconnectReason = {}));
    function reconnectReasonFromJSON(object) {
      switch (object) {
        case 0:
        case "RR_UNKNOWN":
          return ReconnectReason.RR_UNKNOWN;
        case 1:
        case "RR_SIGNAL_DISCONNECTED":
          return ReconnectReason.RR_SIGNAL_DISCONNECTED;
        case 2:
        case "RR_PUBLISHER_FAILED":
          return ReconnectReason.RR_PUBLISHER_FAILED;
        case 3:
        case "RR_SUBSCRIBER_FAILED":
          return ReconnectReason.RR_SUBSCRIBER_FAILED;
        case 4:
        case "RR_SWITCH_CANDIDATE":
          return ReconnectReason.RR_SWITCH_CANDIDATE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ReconnectReason.UNRECOGNIZED;
      }
    }
    exports2.reconnectReasonFromJSON = reconnectReasonFromJSON;
    function reconnectReasonToJSON(object) {
      switch (object) {
        case ReconnectReason.RR_UNKNOWN:
          return "RR_UNKNOWN";
        case ReconnectReason.RR_SIGNAL_DISCONNECTED:
          return "RR_SIGNAL_DISCONNECTED";
        case ReconnectReason.RR_PUBLISHER_FAILED:
          return "RR_PUBLISHER_FAILED";
        case ReconnectReason.RR_SUBSCRIBER_FAILED:
          return "RR_SUBSCRIBER_FAILED";
        case ReconnectReason.RR_SWITCH_CANDIDATE:
          return "RR_SWITCH_CANDIDATE";
        case ReconnectReason.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.reconnectReasonToJSON = reconnectReasonToJSON;
    var SubscriptionError;
    (function(SubscriptionError2) {
      SubscriptionError2[SubscriptionError2["SE_UNKNOWN"] = 0] = "SE_UNKNOWN";
      SubscriptionError2[SubscriptionError2["SE_CODEC_UNSUPPORTED"] = 1] = "SE_CODEC_UNSUPPORTED";
      SubscriptionError2[SubscriptionError2["SE_TRACK_NOTFOUND"] = 2] = "SE_TRACK_NOTFOUND";
      SubscriptionError2[SubscriptionError2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SubscriptionError = exports2.SubscriptionError || (exports2.SubscriptionError = {}));
    function subscriptionErrorFromJSON(object) {
      switch (object) {
        case 0:
        case "SE_UNKNOWN":
          return SubscriptionError.SE_UNKNOWN;
        case 1:
        case "SE_CODEC_UNSUPPORTED":
          return SubscriptionError.SE_CODEC_UNSUPPORTED;
        case 2:
        case "SE_TRACK_NOTFOUND":
          return SubscriptionError.SE_TRACK_NOTFOUND;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SubscriptionError.UNRECOGNIZED;
      }
    }
    exports2.subscriptionErrorFromJSON = subscriptionErrorFromJSON;
    function subscriptionErrorToJSON(object) {
      switch (object) {
        case SubscriptionError.SE_UNKNOWN:
          return "SE_UNKNOWN";
        case SubscriptionError.SE_CODEC_UNSUPPORTED:
          return "SE_CODEC_UNSUPPORTED";
        case SubscriptionError.SE_TRACK_NOTFOUND:
          return "SE_TRACK_NOTFOUND";
        case SubscriptionError.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.subscriptionErrorToJSON = subscriptionErrorToJSON;
    var ParticipantInfo_State;
    (function(ParticipantInfo_State2) {
      ParticipantInfo_State2[ParticipantInfo_State2["JOINING"] = 0] = "JOINING";
      ParticipantInfo_State2[ParticipantInfo_State2["JOINED"] = 1] = "JOINED";
      ParticipantInfo_State2[ParticipantInfo_State2["ACTIVE"] = 2] = "ACTIVE";
      ParticipantInfo_State2[ParticipantInfo_State2["DISCONNECTED"] = 3] = "DISCONNECTED";
      ParticipantInfo_State2[ParticipantInfo_State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ParticipantInfo_State = exports2.ParticipantInfo_State || (exports2.ParticipantInfo_State = {}));
    function participantInfo_StateFromJSON(object) {
      switch (object) {
        case 0:
        case "JOINING":
          return ParticipantInfo_State.JOINING;
        case 1:
        case "JOINED":
          return ParticipantInfo_State.JOINED;
        case 2:
        case "ACTIVE":
          return ParticipantInfo_State.ACTIVE;
        case 3:
        case "DISCONNECTED":
          return ParticipantInfo_State.DISCONNECTED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ParticipantInfo_State.UNRECOGNIZED;
      }
    }
    exports2.participantInfo_StateFromJSON = participantInfo_StateFromJSON;
    function participantInfo_StateToJSON(object) {
      switch (object) {
        case ParticipantInfo_State.JOINING:
          return "JOINING";
        case ParticipantInfo_State.JOINED:
          return "JOINED";
        case ParticipantInfo_State.ACTIVE:
          return "ACTIVE";
        case ParticipantInfo_State.DISCONNECTED:
          return "DISCONNECTED";
        case ParticipantInfo_State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.participantInfo_StateToJSON = participantInfo_StateToJSON;
    var Encryption_Type;
    (function(Encryption_Type2) {
      Encryption_Type2[Encryption_Type2["NONE"] = 0] = "NONE";
      Encryption_Type2[Encryption_Type2["GCM"] = 1] = "GCM";
      Encryption_Type2[Encryption_Type2["CUSTOM"] = 2] = "CUSTOM";
      Encryption_Type2[Encryption_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Encryption_Type = exports2.Encryption_Type || (exports2.Encryption_Type = {}));
    function encryption_TypeFromJSON(object) {
      switch (object) {
        case 0:
        case "NONE":
          return Encryption_Type.NONE;
        case 1:
        case "GCM":
          return Encryption_Type.GCM;
        case 2:
        case "CUSTOM":
          return Encryption_Type.CUSTOM;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Encryption_Type.UNRECOGNIZED;
      }
    }
    exports2.encryption_TypeFromJSON = encryption_TypeFromJSON;
    function encryption_TypeToJSON(object) {
      switch (object) {
        case Encryption_Type.NONE:
          return "NONE";
        case Encryption_Type.GCM:
          return "GCM";
        case Encryption_Type.CUSTOM:
          return "CUSTOM";
        case Encryption_Type.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.encryption_TypeToJSON = encryption_TypeToJSON;
    var DataPacket_Kind;
    (function(DataPacket_Kind2) {
      DataPacket_Kind2[DataPacket_Kind2["RELIABLE"] = 0] = "RELIABLE";
      DataPacket_Kind2[DataPacket_Kind2["LOSSY"] = 1] = "LOSSY";
      DataPacket_Kind2[DataPacket_Kind2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(DataPacket_Kind = exports2.DataPacket_Kind || (exports2.DataPacket_Kind = {}));
    function dataPacket_KindFromJSON(object) {
      switch (object) {
        case 0:
        case "RELIABLE":
          return DataPacket_Kind.RELIABLE;
        case 1:
        case "LOSSY":
          return DataPacket_Kind.LOSSY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return DataPacket_Kind.UNRECOGNIZED;
      }
    }
    exports2.dataPacket_KindFromJSON = dataPacket_KindFromJSON;
    function dataPacket_KindToJSON(object) {
      switch (object) {
        case DataPacket_Kind.RELIABLE:
          return "RELIABLE";
        case DataPacket_Kind.LOSSY:
          return "LOSSY";
        case DataPacket_Kind.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.dataPacket_KindToJSON = dataPacket_KindToJSON;
    var ServerInfo_Edition;
    (function(ServerInfo_Edition2) {
      ServerInfo_Edition2[ServerInfo_Edition2["Standard"] = 0] = "Standard";
      ServerInfo_Edition2[ServerInfo_Edition2["Cloud"] = 1] = "Cloud";
      ServerInfo_Edition2[ServerInfo_Edition2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ServerInfo_Edition = exports2.ServerInfo_Edition || (exports2.ServerInfo_Edition = {}));
    function serverInfo_EditionFromJSON(object) {
      switch (object) {
        case 0:
        case "Standard":
          return ServerInfo_Edition.Standard;
        case 1:
        case "Cloud":
          return ServerInfo_Edition.Cloud;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ServerInfo_Edition.UNRECOGNIZED;
      }
    }
    exports2.serverInfo_EditionFromJSON = serverInfo_EditionFromJSON;
    function serverInfo_EditionToJSON(object) {
      switch (object) {
        case ServerInfo_Edition.Standard:
          return "Standard";
        case ServerInfo_Edition.Cloud:
          return "Cloud";
        case ServerInfo_Edition.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.serverInfo_EditionToJSON = serverInfo_EditionToJSON;
    var ClientInfo_SDK;
    (function(ClientInfo_SDK2) {
      ClientInfo_SDK2[ClientInfo_SDK2["UNKNOWN"] = 0] = "UNKNOWN";
      ClientInfo_SDK2[ClientInfo_SDK2["JS"] = 1] = "JS";
      ClientInfo_SDK2[ClientInfo_SDK2["SWIFT"] = 2] = "SWIFT";
      ClientInfo_SDK2[ClientInfo_SDK2["ANDROID"] = 3] = "ANDROID";
      ClientInfo_SDK2[ClientInfo_SDK2["FLUTTER"] = 4] = "FLUTTER";
      ClientInfo_SDK2[ClientInfo_SDK2["GO"] = 5] = "GO";
      ClientInfo_SDK2[ClientInfo_SDK2["UNITY"] = 6] = "UNITY";
      ClientInfo_SDK2[ClientInfo_SDK2["REACT_NATIVE"] = 7] = "REACT_NATIVE";
      ClientInfo_SDK2[ClientInfo_SDK2["RUST"] = 8] = "RUST";
      ClientInfo_SDK2[ClientInfo_SDK2["PYTHON"] = 9] = "PYTHON";
      ClientInfo_SDK2[ClientInfo_SDK2["CPP"] = 10] = "CPP";
      ClientInfo_SDK2[ClientInfo_SDK2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ClientInfo_SDK = exports2.ClientInfo_SDK || (exports2.ClientInfo_SDK = {}));
    function clientInfo_SDKFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ClientInfo_SDK.UNKNOWN;
        case 1:
        case "JS":
          return ClientInfo_SDK.JS;
        case 2:
        case "SWIFT":
          return ClientInfo_SDK.SWIFT;
        case 3:
        case "ANDROID":
          return ClientInfo_SDK.ANDROID;
        case 4:
        case "FLUTTER":
          return ClientInfo_SDK.FLUTTER;
        case 5:
        case "GO":
          return ClientInfo_SDK.GO;
        case 6:
        case "UNITY":
          return ClientInfo_SDK.UNITY;
        case 7:
        case "REACT_NATIVE":
          return ClientInfo_SDK.REACT_NATIVE;
        case 8:
        case "RUST":
          return ClientInfo_SDK.RUST;
        case 9:
        case "PYTHON":
          return ClientInfo_SDK.PYTHON;
        case 10:
        case "CPP":
          return ClientInfo_SDK.CPP;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ClientInfo_SDK.UNRECOGNIZED;
      }
    }
    exports2.clientInfo_SDKFromJSON = clientInfo_SDKFromJSON;
    function clientInfo_SDKToJSON(object) {
      switch (object) {
        case ClientInfo_SDK.UNKNOWN:
          return "UNKNOWN";
        case ClientInfo_SDK.JS:
          return "JS";
        case ClientInfo_SDK.SWIFT:
          return "SWIFT";
        case ClientInfo_SDK.ANDROID:
          return "ANDROID";
        case ClientInfo_SDK.FLUTTER:
          return "FLUTTER";
        case ClientInfo_SDK.GO:
          return "GO";
        case ClientInfo_SDK.UNITY:
          return "UNITY";
        case ClientInfo_SDK.REACT_NATIVE:
          return "REACT_NATIVE";
        case ClientInfo_SDK.RUST:
          return "RUST";
        case ClientInfo_SDK.PYTHON:
          return "PYTHON";
        case ClientInfo_SDK.CPP:
          return "CPP";
        case ClientInfo_SDK.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.clientInfo_SDKToJSON = clientInfo_SDKToJSON;
    function createBaseRoom() {
      return {
        sid: "",
        name: "",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: 0,
        turnPassword: "",
        enabledCodecs: [],
        metadata: "",
        numParticipants: 0,
        numPublishers: 0,
        activeRecording: false,
        playoutDelay: void 0
      };
    }
    exports2.Room = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
          writer.uint32(10).string(message.sid);
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.emptyTimeout !== 0) {
          writer.uint32(24).uint32(message.emptyTimeout);
        }
        if (message.maxParticipants !== 0) {
          writer.uint32(32).uint32(message.maxParticipants);
        }
        if (message.creationTime !== 0) {
          writer.uint32(40).int64(message.creationTime);
        }
        if (message.turnPassword !== "") {
          writer.uint32(50).string(message.turnPassword);
        }
        for (const v of message.enabledCodecs) {
          exports2.Codec.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(66).string(message.metadata);
        }
        if (message.numParticipants !== 0) {
          writer.uint32(72).uint32(message.numParticipants);
        }
        if (message.numPublishers !== 0) {
          writer.uint32(88).uint32(message.numPublishers);
        }
        if (message.activeRecording === true) {
          writer.uint32(80).bool(message.activeRecording);
        }
        if (message.playoutDelay !== void 0) {
          exports2.PlayoutDelay.encode(message.playoutDelay, writer.uint32(98).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRoom();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sid = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.emptyTimeout = reader.uint32();
              break;
            case 4:
              message.maxParticipants = reader.uint32();
              break;
            case 5:
              message.creationTime = longToNumber(reader.int64());
              break;
            case 6:
              message.turnPassword = reader.string();
              break;
            case 7:
              message.enabledCodecs.push(exports2.Codec.decode(reader, reader.uint32()));
              break;
            case 8:
              message.metadata = reader.string();
              break;
            case 9:
              message.numParticipants = reader.uint32();
              break;
            case 11:
              message.numPublishers = reader.uint32();
              break;
            case 10:
              message.activeRecording = reader.bool();
              break;
            case 12:
              message.playoutDelay = exports2.PlayoutDelay.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sid: isSet(object.sid) ? String(object.sid) : "",
          name: isSet(object.name) ? String(object.name) : "",
          emptyTimeout: isSet(object.emptyTimeout) ? Number(object.emptyTimeout) : 0,
          maxParticipants: isSet(object.maxParticipants) ? Number(object.maxParticipants) : 0,
          creationTime: isSet(object.creationTime) ? Number(object.creationTime) : 0,
          turnPassword: isSet(object.turnPassword) ? String(object.turnPassword) : "",
          enabledCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.enabledCodecs) ? object.enabledCodecs.map((e) => exports2.Codec.fromJSON(e)) : [],
          metadata: isSet(object.metadata) ? String(object.metadata) : "",
          numParticipants: isSet(object.numParticipants) ? Number(object.numParticipants) : 0,
          numPublishers: isSet(object.numPublishers) ? Number(object.numPublishers) : 0,
          activeRecording: isSet(object.activeRecording) ? Boolean(object.activeRecording) : false,
          playoutDelay: isSet(object.playoutDelay) ? exports2.PlayoutDelay.fromJSON(object.playoutDelay) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.sid !== void 0 && (obj.sid = message.sid);
        message.name !== void 0 && (obj.name = message.name);
        message.emptyTimeout !== void 0 && (obj.emptyTimeout = Math.round(message.emptyTimeout));
        message.maxParticipants !== void 0 && (obj.maxParticipants = Math.round(message.maxParticipants));
        message.creationTime !== void 0 && (obj.creationTime = Math.round(message.creationTime));
        message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);
        if (message.enabledCodecs) {
          obj.enabledCodecs = message.enabledCodecs.map((e) => e ? exports2.Codec.toJSON(e) : void 0);
        } else {
          obj.enabledCodecs = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.numParticipants !== void 0 && (obj.numParticipants = Math.round(message.numParticipants));
        message.numPublishers !== void 0 && (obj.numPublishers = Math.round(message.numPublishers));
        message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);
        message.playoutDelay !== void 0 && (obj.playoutDelay = message.playoutDelay ? exports2.PlayoutDelay.toJSON(message.playoutDelay) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = createBaseRoom();
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;
        message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;
        message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;
        message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : "";
        message.enabledCodecs = ((_g = object.enabledCodecs) === null || _g === void 0 ? void 0 : _g.map((e) => exports2.Codec.fromPartial(e))) || [];
        message.metadata = (_h = object.metadata) !== null && _h !== void 0 ? _h : "";
        message.numParticipants = (_j = object.numParticipants) !== null && _j !== void 0 ? _j : 0;
        message.numPublishers = (_k = object.numPublishers) !== null && _k !== void 0 ? _k : 0;
        message.activeRecording = (_l = object.activeRecording) !== null && _l !== void 0 ? _l : false;
        message.playoutDelay = object.playoutDelay !== void 0 && object.playoutDelay !== null ? exports2.PlayoutDelay.fromPartial(object.playoutDelay) : void 0;
        return message;
      }
    };
    function createBaseCodec() {
      return { mime: "", fmtpLine: "" };
    }
    exports2.Codec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mime !== "") {
          writer.uint32(10).string(message.mime);
        }
        if (message.fmtpLine !== "") {
          writer.uint32(18).string(message.fmtpLine);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mime = reader.string();
              break;
            case 2:
              message.fmtpLine = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mime: isSet(object.mime) ? String(object.mime) : "",
          fmtpLine: isSet(object.fmtpLine) ? String(object.fmtpLine) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.mime !== void 0 && (obj.mime = message.mime);
        message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCodec();
        message.mime = (_a = object.mime) !== null && _a !== void 0 ? _a : "";
        message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBasePlayoutDelay() {
      return { enabled: false, min: 0 };
    }
    exports2.PlayoutDelay = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enabled === true) {
          writer.uint32(8).bool(message.enabled);
        }
        if (message.min !== 0) {
          writer.uint32(16).uint32(message.min);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlayoutDelay();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.enabled = reader.bool();
              break;
            case 2:
              message.min = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,
          min: isSet(object.min) ? Number(object.min) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        message.min !== void 0 && (obj.min = Math.round(message.min));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePlayoutDelay();
        message.enabled = (_a = object.enabled) !== null && _a !== void 0 ? _a : false;
        message.min = (_b = object.min) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseParticipantPermission() {
      return {
        canSubscribe: false,
        canPublish: false,
        canPublishData: false,
        canPublishSources: [],
        hidden: false,
        recorder: false,
        canUpdateMetadata: false
      };
    }
    exports2.ParticipantPermission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.canSubscribe === true) {
          writer.uint32(8).bool(message.canSubscribe);
        }
        if (message.canPublish === true) {
          writer.uint32(16).bool(message.canPublish);
        }
        if (message.canPublishData === true) {
          writer.uint32(24).bool(message.canPublishData);
        }
        writer.uint32(74).fork();
        for (const v of message.canPublishSources) {
          writer.int32(v);
        }
        writer.ldelim();
        if (message.hidden === true) {
          writer.uint32(56).bool(message.hidden);
        }
        if (message.recorder === true) {
          writer.uint32(64).bool(message.recorder);
        }
        if (message.canUpdateMetadata === true) {
          writer.uint32(80).bool(message.canUpdateMetadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParticipantPermission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.canSubscribe = reader.bool();
              break;
            case 2:
              message.canPublish = reader.bool();
              break;
            case 3:
              message.canPublishData = reader.bool();
              break;
            case 9:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.canPublishSources.push(reader.int32());
                }
              } else {
                message.canPublishSources.push(reader.int32());
              }
              break;
            case 7:
              message.hidden = reader.bool();
              break;
            case 8:
              message.recorder = reader.bool();
              break;
            case 10:
              message.canUpdateMetadata = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          canSubscribe: isSet(object.canSubscribe) ? Boolean(object.canSubscribe) : false,
          canPublish: isSet(object.canPublish) ? Boolean(object.canPublish) : false,
          canPublishData: isSet(object.canPublishData) ? Boolean(object.canPublishData) : false,
          canPublishSources: Array.isArray(object === null || object === void 0 ? void 0 : object.canPublishSources) ? object.canPublishSources.map((e) => trackSourceFromJSON(e)) : [],
          hidden: isSet(object.hidden) ? Boolean(object.hidden) : false,
          recorder: isSet(object.recorder) ? Boolean(object.recorder) : false,
          canUpdateMetadata: isSet(object.canUpdateMetadata) ? Boolean(object.canUpdateMetadata) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.canSubscribe !== void 0 && (obj.canSubscribe = message.canSubscribe);
        message.canPublish !== void 0 && (obj.canPublish = message.canPublish);
        message.canPublishData !== void 0 && (obj.canPublishData = message.canPublishData);
        if (message.canPublishSources) {
          obj.canPublishSources = message.canPublishSources.map((e) => trackSourceToJSON(e));
        } else {
          obj.canPublishSources = [];
        }
        message.hidden !== void 0 && (obj.hidden = message.hidden);
        message.recorder !== void 0 && (obj.recorder = message.recorder);
        message.canUpdateMetadata !== void 0 && (obj.canUpdateMetadata = message.canUpdateMetadata);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseParticipantPermission();
        message.canSubscribe = (_a = object.canSubscribe) !== null && _a !== void 0 ? _a : false;
        message.canPublish = (_b = object.canPublish) !== null && _b !== void 0 ? _b : false;
        message.canPublishData = (_c = object.canPublishData) !== null && _c !== void 0 ? _c : false;
        message.canPublishSources = ((_d = object.canPublishSources) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.hidden = (_e = object.hidden) !== null && _e !== void 0 ? _e : false;
        message.recorder = (_f = object.recorder) !== null && _f !== void 0 ? _f : false;
        message.canUpdateMetadata = (_g = object.canUpdateMetadata) !== null && _g !== void 0 ? _g : false;
        return message;
      }
    };
    function createBaseParticipantInfo() {
      return {
        sid: "",
        identity: "",
        state: 0,
        tracks: [],
        metadata: "",
        joinedAt: 0,
        name: "",
        version: 0,
        permission: void 0,
        region: "",
        isPublisher: false
      };
    }
    exports2.ParticipantInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
          writer.uint32(10).string(message.sid);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        for (const v of message.tracks) {
          exports2.TrackInfo.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(42).string(message.metadata);
        }
        if (message.joinedAt !== 0) {
          writer.uint32(48).int64(message.joinedAt);
        }
        if (message.name !== "") {
          writer.uint32(74).string(message.name);
        }
        if (message.version !== 0) {
          writer.uint32(80).uint32(message.version);
        }
        if (message.permission !== void 0) {
          exports2.ParticipantPermission.encode(message.permission, writer.uint32(90).fork()).ldelim();
        }
        if (message.region !== "") {
          writer.uint32(98).string(message.region);
        }
        if (message.isPublisher === true) {
          writer.uint32(104).bool(message.isPublisher);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParticipantInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sid = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.tracks.push(exports2.TrackInfo.decode(reader, reader.uint32()));
              break;
            case 5:
              message.metadata = reader.string();
              break;
            case 6:
              message.joinedAt = longToNumber(reader.int64());
              break;
            case 9:
              message.name = reader.string();
              break;
            case 10:
              message.version = reader.uint32();
              break;
            case 11:
              message.permission = exports2.ParticipantPermission.decode(reader, reader.uint32());
              break;
            case 12:
              message.region = reader.string();
              break;
            case 13:
              message.isPublisher = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sid: isSet(object.sid) ? String(object.sid) : "",
          identity: isSet(object.identity) ? String(object.identity) : "",
          state: isSet(object.state) ? participantInfo_StateFromJSON(object.state) : 0,
          tracks: Array.isArray(object === null || object === void 0 ? void 0 : object.tracks) ? object.tracks.map((e) => exports2.TrackInfo.fromJSON(e)) : [],
          metadata: isSet(object.metadata) ? String(object.metadata) : "",
          joinedAt: isSet(object.joinedAt) ? Number(object.joinedAt) : 0,
          name: isSet(object.name) ? String(object.name) : "",
          version: isSet(object.version) ? Number(object.version) : 0,
          permission: isSet(object.permission) ? exports2.ParticipantPermission.fromJSON(object.permission) : void 0,
          region: isSet(object.region) ? String(object.region) : "",
          isPublisher: isSet(object.isPublisher) ? Boolean(object.isPublisher) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.sid !== void 0 && (obj.sid = message.sid);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.state !== void 0 && (obj.state = participantInfo_StateToJSON(message.state));
        if (message.tracks) {
          obj.tracks = message.tracks.map((e) => e ? exports2.TrackInfo.toJSON(e) : void 0);
        } else {
          obj.tracks = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.joinedAt !== void 0 && (obj.joinedAt = Math.round(message.joinedAt));
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = Math.round(message.version));
        message.permission !== void 0 && (obj.permission = message.permission ? exports2.ParticipantPermission.toJSON(message.permission) : void 0);
        message.region !== void 0 && (obj.region = message.region);
        message.isPublisher !== void 0 && (obj.isPublisher = message.isPublisher);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseParticipantInfo();
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        message.tracks = ((_d = object.tracks) === null || _d === void 0 ? void 0 : _d.map((e) => exports2.TrackInfo.fromPartial(e))) || [];
        message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : "";
        message.joinedAt = (_f = object.joinedAt) !== null && _f !== void 0 ? _f : 0;
        message.name = (_g = object.name) !== null && _g !== void 0 ? _g : "";
        message.version = (_h = object.version) !== null && _h !== void 0 ? _h : 0;
        message.permission = object.permission !== void 0 && object.permission !== null ? exports2.ParticipantPermission.fromPartial(object.permission) : void 0;
        message.region = (_j = object.region) !== null && _j !== void 0 ? _j : "";
        message.isPublisher = (_k = object.isPublisher) !== null && _k !== void 0 ? _k : false;
        return message;
      }
    };
    function createBaseEncryption() {
      return {};
    }
    exports2.Encryption = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEncryption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseEncryption();
        return message;
      }
    };
    function createBaseSimulcastCodecInfo() {
      return { mimeType: "", mid: "", cid: "", layers: [] };
    }
    exports2.SimulcastCodecInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mimeType !== "") {
          writer.uint32(10).string(message.mimeType);
        }
        if (message.mid !== "") {
          writer.uint32(18).string(message.mid);
        }
        if (message.cid !== "") {
          writer.uint32(26).string(message.cid);
        }
        for (const v of message.layers) {
          exports2.VideoLayer.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulcastCodecInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mimeType = reader.string();
              break;
            case 2:
              message.mid = reader.string();
              break;
            case 3:
              message.cid = reader.string();
              break;
            case 4:
              message.layers.push(exports2.VideoLayer.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mimeType: isSet(object.mimeType) ? String(object.mimeType) : "",
          mid: isSet(object.mid) ? String(object.mid) : "",
          cid: isSet(object.cid) ? String(object.cid) : "",
          layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => exports2.VideoLayer.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
        message.mid !== void 0 && (obj.mid = message.mid);
        message.cid !== void 0 && (obj.cid = message.cid);
        if (message.layers) {
          obj.layers = message.layers.map((e) => e ? exports2.VideoLayer.toJSON(e) : void 0);
        } else {
          obj.layers = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSimulcastCodecInfo();
        message.mimeType = (_a = object.mimeType) !== null && _a !== void 0 ? _a : "";
        message.mid = (_b = object.mid) !== null && _b !== void 0 ? _b : "";
        message.cid = (_c = object.cid) !== null && _c !== void 0 ? _c : "";
        message.layers = ((_d = object.layers) === null || _d === void 0 ? void 0 : _d.map((e) => exports2.VideoLayer.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseTrackInfo() {
      return {
        sid: "",
        type: 0,
        name: "",
        muted: false,
        width: 0,
        height: 0,
        simulcast: false,
        disableDtx: false,
        source: 0,
        layers: [],
        mimeType: "",
        mid: "",
        codecs: [],
        stereo: false,
        disableRed: false,
        encryption: 0,
        stream: ""
      };
    }
    exports2.TrackInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
          writer.uint32(10).string(message.sid);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        if (message.name !== "") {
          writer.uint32(26).string(message.name);
        }
        if (message.muted === true) {
          writer.uint32(32).bool(message.muted);
        }
        if (message.width !== 0) {
          writer.uint32(40).uint32(message.width);
        }
        if (message.height !== 0) {
          writer.uint32(48).uint32(message.height);
        }
        if (message.simulcast === true) {
          writer.uint32(56).bool(message.simulcast);
        }
        if (message.disableDtx === true) {
          writer.uint32(64).bool(message.disableDtx);
        }
        if (message.source !== 0) {
          writer.uint32(72).int32(message.source);
        }
        for (const v of message.layers) {
          exports2.VideoLayer.encode(v, writer.uint32(82).fork()).ldelim();
        }
        if (message.mimeType !== "") {
          writer.uint32(90).string(message.mimeType);
        }
        if (message.mid !== "") {
          writer.uint32(98).string(message.mid);
        }
        for (const v of message.codecs) {
          exports2.SimulcastCodecInfo.encode(v, writer.uint32(106).fork()).ldelim();
        }
        if (message.stereo === true) {
          writer.uint32(112).bool(message.stereo);
        }
        if (message.disableRed === true) {
          writer.uint32(120).bool(message.disableRed);
        }
        if (message.encryption !== 0) {
          writer.uint32(128).int32(message.encryption);
        }
        if (message.stream !== "") {
          writer.uint32(138).string(message.stream);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTrackInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sid = reader.string();
              break;
            case 2:
              message.type = reader.int32();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.muted = reader.bool();
              break;
            case 5:
              message.width = reader.uint32();
              break;
            case 6:
              message.height = reader.uint32();
              break;
            case 7:
              message.simulcast = reader.bool();
              break;
            case 8:
              message.disableDtx = reader.bool();
              break;
            case 9:
              message.source = reader.int32();
              break;
            case 10:
              message.layers.push(exports2.VideoLayer.decode(reader, reader.uint32()));
              break;
            case 11:
              message.mimeType = reader.string();
              break;
            case 12:
              message.mid = reader.string();
              break;
            case 13:
              message.codecs.push(exports2.SimulcastCodecInfo.decode(reader, reader.uint32()));
              break;
            case 14:
              message.stereo = reader.bool();
              break;
            case 15:
              message.disableRed = reader.bool();
              break;
            case 16:
              message.encryption = reader.int32();
              break;
            case 17:
              message.stream = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sid: isSet(object.sid) ? String(object.sid) : "",
          type: isSet(object.type) ? trackTypeFromJSON(object.type) : 0,
          name: isSet(object.name) ? String(object.name) : "",
          muted: isSet(object.muted) ? Boolean(object.muted) : false,
          width: isSet(object.width) ? Number(object.width) : 0,
          height: isSet(object.height) ? Number(object.height) : 0,
          simulcast: isSet(object.simulcast) ? Boolean(object.simulcast) : false,
          disableDtx: isSet(object.disableDtx) ? Boolean(object.disableDtx) : false,
          source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,
          layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => exports2.VideoLayer.fromJSON(e)) : [],
          mimeType: isSet(object.mimeType) ? String(object.mimeType) : "",
          mid: isSet(object.mid) ? String(object.mid) : "",
          codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e) => exports2.SimulcastCodecInfo.fromJSON(e)) : [],
          stereo: isSet(object.stereo) ? Boolean(object.stereo) : false,
          disableRed: isSet(object.disableRed) ? Boolean(object.disableRed) : false,
          encryption: isSet(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0,
          stream: isSet(object.stream) ? String(object.stream) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sid !== void 0 && (obj.sid = message.sid);
        message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));
        message.name !== void 0 && (obj.name = message.name);
        message.muted !== void 0 && (obj.muted = message.muted);
        message.width !== void 0 && (obj.width = Math.round(message.width));
        message.height !== void 0 && (obj.height = Math.round(message.height));
        message.simulcast !== void 0 && (obj.simulcast = message.simulcast);
        message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
        message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));
        if (message.layers) {
          obj.layers = message.layers.map((e) => e ? exports2.VideoLayer.toJSON(e) : void 0);
        } else {
          obj.layers = [];
        }
        message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
        message.mid !== void 0 && (obj.mid = message.mid);
        if (message.codecs) {
          obj.codecs = message.codecs.map((e) => e ? exports2.SimulcastCodecInfo.toJSON(e) : void 0);
        } else {
          obj.codecs = [];
        }
        message.stereo !== void 0 && (obj.stereo = message.stereo);
        message.disableRed !== void 0 && (obj.disableRed = message.disableRed);
        message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));
        message.stream !== void 0 && (obj.stream = message.stream);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        const message = createBaseTrackInfo();
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
        message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
        message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;
        message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;
        message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;
        message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;
        message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;
        message.layers = ((_k = object.layers) === null || _k === void 0 ? void 0 : _k.map((e) => exports2.VideoLayer.fromPartial(e))) || [];
        message.mimeType = (_l = object.mimeType) !== null && _l !== void 0 ? _l : "";
        message.mid = (_m = object.mid) !== null && _m !== void 0 ? _m : "";
        message.codecs = ((_o = object.codecs) === null || _o === void 0 ? void 0 : _o.map((e) => exports2.SimulcastCodecInfo.fromPartial(e))) || [];
        message.stereo = (_p = object.stereo) !== null && _p !== void 0 ? _p : false;
        message.disableRed = (_q = object.disableRed) !== null && _q !== void 0 ? _q : false;
        message.encryption = (_r = object.encryption) !== null && _r !== void 0 ? _r : 0;
        message.stream = (_s = object.stream) !== null && _s !== void 0 ? _s : "";
        return message;
      }
    };
    function createBaseVideoLayer() {
      return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
    }
    exports2.VideoLayer = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quality !== 0) {
          writer.uint32(8).int32(message.quality);
        }
        if (message.width !== 0) {
          writer.uint32(16).uint32(message.width);
        }
        if (message.height !== 0) {
          writer.uint32(24).uint32(message.height);
        }
        if (message.bitrate !== 0) {
          writer.uint32(32).uint32(message.bitrate);
        }
        if (message.ssrc !== 0) {
          writer.uint32(40).uint32(message.ssrc);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVideoLayer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quality = reader.int32();
              break;
            case 2:
              message.width = reader.uint32();
              break;
            case 3:
              message.height = reader.uint32();
              break;
            case 4:
              message.bitrate = reader.uint32();
              break;
            case 5:
              message.ssrc = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,
          width: isSet(object.width) ? Number(object.width) : 0,
          height: isSet(object.height) ? Number(object.height) : 0,
          bitrate: isSet(object.bitrate) ? Number(object.bitrate) : 0,
          ssrc: isSet(object.ssrc) ? Number(object.ssrc) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));
        message.width !== void 0 && (obj.width = Math.round(message.width));
        message.height !== void 0 && (obj.height = Math.round(message.height));
        message.bitrate !== void 0 && (obj.bitrate = Math.round(message.bitrate));
        message.ssrc !== void 0 && (obj.ssrc = Math.round(message.ssrc));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseVideoLayer();
        message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;
        message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
        message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;
        message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;
        return message;
      }
    };
    function createBaseDataPacket() {
      return { kind: 0, user: void 0, speaker: void 0 };
    }
    exports2.DataPacket = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.kind !== 0) {
          writer.uint32(8).int32(message.kind);
        }
        if (message.user !== void 0) {
          exports2.UserPacket.encode(message.user, writer.uint32(18).fork()).ldelim();
        }
        if (message.speaker !== void 0) {
          exports2.ActiveSpeakerUpdate.encode(message.speaker, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDataPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.kind = reader.int32();
              break;
            case 2:
              message.user = exports2.UserPacket.decode(reader, reader.uint32());
              break;
            case 3:
              message.speaker = exports2.ActiveSpeakerUpdate.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          kind: isSet(object.kind) ? dataPacket_KindFromJSON(object.kind) : 0,
          user: isSet(object.user) ? exports2.UserPacket.fromJSON(object.user) : void 0,
          speaker: isSet(object.speaker) ? exports2.ActiveSpeakerUpdate.fromJSON(object.speaker) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON(message.kind));
        message.user !== void 0 && (obj.user = message.user ? exports2.UserPacket.toJSON(message.user) : void 0);
        message.speaker !== void 0 && (obj.speaker = message.speaker ? exports2.ActiveSpeakerUpdate.toJSON(message.speaker) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDataPacket();
        message.kind = (_a = object.kind) !== null && _a !== void 0 ? _a : 0;
        message.user = object.user !== void 0 && object.user !== null ? exports2.UserPacket.fromPartial(object.user) : void 0;
        message.speaker = object.speaker !== void 0 && object.speaker !== null ? exports2.ActiveSpeakerUpdate.fromPartial(object.speaker) : void 0;
        return message;
      }
    };
    function createBaseActiveSpeakerUpdate() {
      return { speakers: [] };
    }
    exports2.ActiveSpeakerUpdate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.speakers) {
          exports2.SpeakerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseActiveSpeakerUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.speakers.push(exports2.SpeakerInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e) => exports2.SpeakerInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.speakers) {
          obj.speakers = message.speakers.map((e) => e ? exports2.SpeakerInfo.toJSON(e) : void 0);
        } else {
          obj.speakers = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseActiveSpeakerUpdate();
        message.speakers = ((_a = object.speakers) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.SpeakerInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSpeakerInfo() {
      return { sid: "", level: 0, active: false };
    }
    exports2.SpeakerInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
          writer.uint32(10).string(message.sid);
        }
        if (message.level !== 0) {
          writer.uint32(21).float(message.level);
        }
        if (message.active === true) {
          writer.uint32(24).bool(message.active);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSpeakerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sid = reader.string();
              break;
            case 2:
              message.level = reader.float();
              break;
            case 3:
              message.active = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sid: isSet(object.sid) ? String(object.sid) : "",
          level: isSet(object.level) ? Number(object.level) : 0,
          active: isSet(object.active) ? Boolean(object.active) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.sid !== void 0 && (obj.sid = message.sid);
        message.level !== void 0 && (obj.level = message.level);
        message.active !== void 0 && (obj.active = message.active);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSpeakerInfo();
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;
        message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    function createBaseUserPacket() {
      return { participantSid: "", payload: new Uint8Array(), destinationSids: [], topic: void 0 };
    }
    exports2.UserPacket = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
          writer.uint32(10).string(message.participantSid);
        }
        if (message.payload.length !== 0) {
          writer.uint32(18).bytes(message.payload);
        }
        for (const v of message.destinationSids) {
          writer.uint32(26).string(v);
        }
        if (message.topic !== void 0) {
          writer.uint32(34).string(message.topic);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.participantSid = reader.string();
              break;
            case 2:
              message.payload = reader.bytes();
              break;
            case 3:
              message.destinationSids.push(reader.string());
              break;
            case 4:
              message.topic = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          participantSid: isSet(object.participantSid) ? String(object.participantSid) : "",
          payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
          destinationSids: Array.isArray(object === null || object === void 0 ? void 0 : object.destinationSids) ? object.destinationSids.map((e) => String(e)) : [],
          topic: isSet(object.topic) ? String(object.topic) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
        message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));
        if (message.destinationSids) {
          obj.destinationSids = message.destinationSids.map((e) => e);
        } else {
          obj.destinationSids = [];
        }
        message.topic !== void 0 && (obj.topic = message.topic);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseUserPacket();
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.destinationSids = ((_c = object.destinationSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.topic = (_d = object.topic) !== null && _d !== void 0 ? _d : void 0;
        return message;
      }
    };
    function createBaseParticipantTracks() {
      return { participantSid: "", trackSids: [] };
    }
    exports2.ParticipantTracks = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
          writer.uint32(10).string(message.participantSid);
        }
        for (const v of message.trackSids) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParticipantTracks();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.participantSid = reader.string();
              break;
            case 2:
              message.trackSids.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          participantSid: isSet(object.participantSid) ? String(object.participantSid) : "",
          trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
        if (message.trackSids) {
          obj.trackSids = message.trackSids.map((e) => e);
        } else {
          obj.trackSids = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseParticipantTracks();
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.trackSids = ((_b = object.trackSids) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseServerInfo() {
      return { edition: 0, version: "", protocol: 0, region: "", nodeId: "", debugInfo: "" };
    }
    exports2.ServerInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.edition !== 0) {
          writer.uint32(8).int32(message.edition);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (message.protocol !== 0) {
          writer.uint32(24).int32(message.protocol);
        }
        if (message.region !== "") {
          writer.uint32(34).string(message.region);
        }
        if (message.nodeId !== "") {
          writer.uint32(42).string(message.nodeId);
        }
        if (message.debugInfo !== "") {
          writer.uint32(50).string(message.debugInfo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseServerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.edition = reader.int32();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.protocol = reader.int32();
              break;
            case 4:
              message.region = reader.string();
              break;
            case 5:
              message.nodeId = reader.string();
              break;
            case 6:
              message.debugInfo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          edition: isSet(object.edition) ? serverInfo_EditionFromJSON(object.edition) : 0,
          version: isSet(object.version) ? String(object.version) : "",
          protocol: isSet(object.protocol) ? Number(object.protocol) : 0,
          region: isSet(object.region) ? String(object.region) : "",
          nodeId: isSet(object.nodeId) ? String(object.nodeId) : "",
          debugInfo: isSet(object.debugInfo) ? String(object.debugInfo) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.edition !== void 0 && (obj.edition = serverInfo_EditionToJSON(message.edition));
        message.version !== void 0 && (obj.version = message.version);
        message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));
        message.region !== void 0 && (obj.region = message.region);
        message.nodeId !== void 0 && (obj.nodeId = message.nodeId);
        message.debugInfo !== void 0 && (obj.debugInfo = message.debugInfo);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseServerInfo();
        message.edition = (_a = object.edition) !== null && _a !== void 0 ? _a : 0;
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
        message.region = (_d = object.region) !== null && _d !== void 0 ? _d : "";
        message.nodeId = (_e = object.nodeId) !== null && _e !== void 0 ? _e : "";
        message.debugInfo = (_f = object.debugInfo) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseClientInfo() {
      return {
        sdk: 0,
        version: "",
        protocol: 0,
        os: "",
        osVersion: "",
        deviceModel: "",
        browser: "",
        browserVersion: "",
        address: "",
        network: ""
      };
    }
    exports2.ClientInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sdk !== 0) {
          writer.uint32(8).int32(message.sdk);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (message.protocol !== 0) {
          writer.uint32(24).int32(message.protocol);
        }
        if (message.os !== "") {
          writer.uint32(34).string(message.os);
        }
        if (message.osVersion !== "") {
          writer.uint32(42).string(message.osVersion);
        }
        if (message.deviceModel !== "") {
          writer.uint32(50).string(message.deviceModel);
        }
        if (message.browser !== "") {
          writer.uint32(58).string(message.browser);
        }
        if (message.browserVersion !== "") {
          writer.uint32(66).string(message.browserVersion);
        }
        if (message.address !== "") {
          writer.uint32(74).string(message.address);
        }
        if (message.network !== "") {
          writer.uint32(82).string(message.network);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sdk = reader.int32();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.protocol = reader.int32();
              break;
            case 4:
              message.os = reader.string();
              break;
            case 5:
              message.osVersion = reader.string();
              break;
            case 6:
              message.deviceModel = reader.string();
              break;
            case 7:
              message.browser = reader.string();
              break;
            case 8:
              message.browserVersion = reader.string();
              break;
            case 9:
              message.address = reader.string();
              break;
            case 10:
              message.network = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sdk: isSet(object.sdk) ? clientInfo_SDKFromJSON(object.sdk) : 0,
          version: isSet(object.version) ? String(object.version) : "",
          protocol: isSet(object.protocol) ? Number(object.protocol) : 0,
          os: isSet(object.os) ? String(object.os) : "",
          osVersion: isSet(object.osVersion) ? String(object.osVersion) : "",
          deviceModel: isSet(object.deviceModel) ? String(object.deviceModel) : "",
          browser: isSet(object.browser) ? String(object.browser) : "",
          browserVersion: isSet(object.browserVersion) ? String(object.browserVersion) : "",
          address: isSet(object.address) ? String(object.address) : "",
          network: isSet(object.network) ? String(object.network) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sdk !== void 0 && (obj.sdk = clientInfo_SDKToJSON(message.sdk));
        message.version !== void 0 && (obj.version = message.version);
        message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));
        message.os !== void 0 && (obj.os = message.os);
        message.osVersion !== void 0 && (obj.osVersion = message.osVersion);
        message.deviceModel !== void 0 && (obj.deviceModel = message.deviceModel);
        message.browser !== void 0 && (obj.browser = message.browser);
        message.browserVersion !== void 0 && (obj.browserVersion = message.browserVersion);
        message.address !== void 0 && (obj.address = message.address);
        message.network !== void 0 && (obj.network = message.network);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseClientInfo();
        message.sdk = (_a = object.sdk) !== null && _a !== void 0 ? _a : 0;
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
        message.os = (_d = object.os) !== null && _d !== void 0 ? _d : "";
        message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : "";
        message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
        message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : "";
        message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : "";
        message.address = (_j = object.address) !== null && _j !== void 0 ? _j : "";
        message.network = (_k = object.network) !== null && _k !== void 0 ? _k : "";
        return message;
      }
    };
    function createBaseClientConfiguration() {
      return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };
    }
    exports2.ClientConfiguration = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.video !== void 0) {
          exports2.VideoConfiguration.encode(message.video, writer.uint32(10).fork()).ldelim();
        }
        if (message.screen !== void 0) {
          exports2.VideoConfiguration.encode(message.screen, writer.uint32(18).fork()).ldelim();
        }
        if (message.resumeConnection !== 0) {
          writer.uint32(24).int32(message.resumeConnection);
        }
        if (message.disabledCodecs !== void 0) {
          exports2.DisabledCodecs.encode(message.disabledCodecs, writer.uint32(34).fork()).ldelim();
        }
        if (message.forceRelay !== 0) {
          writer.uint32(40).int32(message.forceRelay);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConfiguration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.video = exports2.VideoConfiguration.decode(reader, reader.uint32());
              break;
            case 2:
              message.screen = exports2.VideoConfiguration.decode(reader, reader.uint32());
              break;
            case 3:
              message.resumeConnection = reader.int32();
              break;
            case 4:
              message.disabledCodecs = exports2.DisabledCodecs.decode(reader, reader.uint32());
              break;
            case 5:
              message.forceRelay = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          video: isSet(object.video) ? exports2.VideoConfiguration.fromJSON(object.video) : void 0,
          screen: isSet(object.screen) ? exports2.VideoConfiguration.fromJSON(object.screen) : void 0,
          resumeConnection: isSet(object.resumeConnection) ? clientConfigSettingFromJSON(object.resumeConnection) : 0,
          disabledCodecs: isSet(object.disabledCodecs) ? exports2.DisabledCodecs.fromJSON(object.disabledCodecs) : void 0,
          forceRelay: isSet(object.forceRelay) ? clientConfigSettingFromJSON(object.forceRelay) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.video !== void 0 && (obj.video = message.video ? exports2.VideoConfiguration.toJSON(message.video) : void 0);
        message.screen !== void 0 && (obj.screen = message.screen ? exports2.VideoConfiguration.toJSON(message.screen) : void 0);
        message.resumeConnection !== void 0 && (obj.resumeConnection = clientConfigSettingToJSON(message.resumeConnection));
        message.disabledCodecs !== void 0 && (obj.disabledCodecs = message.disabledCodecs ? exports2.DisabledCodecs.toJSON(message.disabledCodecs) : void 0);
        message.forceRelay !== void 0 && (obj.forceRelay = clientConfigSettingToJSON(message.forceRelay));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseClientConfiguration();
        message.video = object.video !== void 0 && object.video !== null ? exports2.VideoConfiguration.fromPartial(object.video) : void 0;
        message.screen = object.screen !== void 0 && object.screen !== null ? exports2.VideoConfiguration.fromPartial(object.screen) : void 0;
        message.resumeConnection = (_a = object.resumeConnection) !== null && _a !== void 0 ? _a : 0;
        message.disabledCodecs = object.disabledCodecs !== void 0 && object.disabledCodecs !== null ? exports2.DisabledCodecs.fromPartial(object.disabledCodecs) : void 0;
        message.forceRelay = (_b = object.forceRelay) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseVideoConfiguration() {
      return { hardwareEncoder: 0 };
    }
    exports2.VideoConfiguration = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hardwareEncoder !== 0) {
          writer.uint32(8).int32(message.hardwareEncoder);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVideoConfiguration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hardwareEncoder = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { hardwareEncoder: isSet(object.hardwareEncoder) ? clientConfigSettingFromJSON(object.hardwareEncoder) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.hardwareEncoder !== void 0 && (obj.hardwareEncoder = clientConfigSettingToJSON(message.hardwareEncoder));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseVideoConfiguration();
        message.hardwareEncoder = (_a = object.hardwareEncoder) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseDisabledCodecs() {
      return { codecs: [], publish: [] };
    }
    exports2.DisabledCodecs = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.codecs) {
          exports2.Codec.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.publish) {
          exports2.Codec.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDisabledCodecs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codecs.push(exports2.Codec.decode(reader, reader.uint32()));
              break;
            case 2:
              message.publish.push(exports2.Codec.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e) => exports2.Codec.fromJSON(e)) : [],
          publish: Array.isArray(object === null || object === void 0 ? void 0 : object.publish) ? object.publish.map((e) => exports2.Codec.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.codecs) {
          obj.codecs = message.codecs.map((e) => e ? exports2.Codec.toJSON(e) : void 0);
        } else {
          obj.codecs = [];
        }
        if (message.publish) {
          obj.publish = message.publish.map((e) => e ? exports2.Codec.toJSON(e) : void 0);
        } else {
          obj.publish = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDisabledCodecs();
        message.codecs = ((_a = object.codecs) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Codec.fromPartial(e))) || [];
        message.publish = ((_b = object.publish) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.Codec.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseRTPStats() {
      return {
        startTime: void 0,
        endTime: void 0,
        duration: 0,
        packets: 0,
        packetRate: 0,
        bytes: 0,
        headerBytes: 0,
        bitrate: 0,
        packetsLost: 0,
        packetLossRate: 0,
        packetLossPercentage: 0,
        packetsDuplicate: 0,
        packetDuplicateRate: 0,
        bytesDuplicate: 0,
        headerBytesDuplicate: 0,
        bitrateDuplicate: 0,
        packetsPadding: 0,
        packetPaddingRate: 0,
        bytesPadding: 0,
        headerBytesPadding: 0,
        bitratePadding: 0,
        packetsOutOfOrder: 0,
        frames: 0,
        frameRate: 0,
        jitterCurrent: 0,
        jitterMax: 0,
        gapHistogram: {},
        nacks: 0,
        nackAcks: 0,
        nackMisses: 0,
        nackRepeated: 0,
        plis: 0,
        lastPli: void 0,
        firs: 0,
        lastFir: void 0,
        rttCurrent: 0,
        rttMax: 0,
        keyFrames: 0,
        lastKeyFrame: void 0,
        layerLockPlis: 0,
        lastLayerLockPli: void 0,
        sampleRate: 0,
        driftMs: 0
      };
    }
    exports2.RTPStats = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.startTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).ldelim();
        }
        if (message.endTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.duration !== 0) {
          writer.uint32(25).double(message.duration);
        }
        if (message.packets !== 0) {
          writer.uint32(32).uint32(message.packets);
        }
        if (message.packetRate !== 0) {
          writer.uint32(41).double(message.packetRate);
        }
        if (message.bytes !== 0) {
          writer.uint32(48).uint64(message.bytes);
        }
        if (message.headerBytes !== 0) {
          writer.uint32(312).uint64(message.headerBytes);
        }
        if (message.bitrate !== 0) {
          writer.uint32(57).double(message.bitrate);
        }
        if (message.packetsLost !== 0) {
          writer.uint32(64).uint32(message.packetsLost);
        }
        if (message.packetLossRate !== 0) {
          writer.uint32(73).double(message.packetLossRate);
        }
        if (message.packetLossPercentage !== 0) {
          writer.uint32(85).float(message.packetLossPercentage);
        }
        if (message.packetsDuplicate !== 0) {
          writer.uint32(88).uint32(message.packetsDuplicate);
        }
        if (message.packetDuplicateRate !== 0) {
          writer.uint32(97).double(message.packetDuplicateRate);
        }
        if (message.bytesDuplicate !== 0) {
          writer.uint32(104).uint64(message.bytesDuplicate);
        }
        if (message.headerBytesDuplicate !== 0) {
          writer.uint32(320).uint64(message.headerBytesDuplicate);
        }
        if (message.bitrateDuplicate !== 0) {
          writer.uint32(113).double(message.bitrateDuplicate);
        }
        if (message.packetsPadding !== 0) {
          writer.uint32(120).uint32(message.packetsPadding);
        }
        if (message.packetPaddingRate !== 0) {
          writer.uint32(129).double(message.packetPaddingRate);
        }
        if (message.bytesPadding !== 0) {
          writer.uint32(136).uint64(message.bytesPadding);
        }
        if (message.headerBytesPadding !== 0) {
          writer.uint32(328).uint64(message.headerBytesPadding);
        }
        if (message.bitratePadding !== 0) {
          writer.uint32(145).double(message.bitratePadding);
        }
        if (message.packetsOutOfOrder !== 0) {
          writer.uint32(152).uint32(message.packetsOutOfOrder);
        }
        if (message.frames !== 0) {
          writer.uint32(160).uint32(message.frames);
        }
        if (message.frameRate !== 0) {
          writer.uint32(169).double(message.frameRate);
        }
        if (message.jitterCurrent !== 0) {
          writer.uint32(177).double(message.jitterCurrent);
        }
        if (message.jitterMax !== 0) {
          writer.uint32(185).double(message.jitterMax);
        }
        Object.entries(message.gapHistogram).forEach(([key, value]) => {
          exports2.RTPStats_GapHistogramEntry.encode({ key, value }, writer.uint32(194).fork()).ldelim();
        });
        if (message.nacks !== 0) {
          writer.uint32(200).uint32(message.nacks);
        }
        if (message.nackAcks !== 0) {
          writer.uint32(296).uint32(message.nackAcks);
        }
        if (message.nackMisses !== 0) {
          writer.uint32(208).uint32(message.nackMisses);
        }
        if (message.nackRepeated !== 0) {
          writer.uint32(304).uint32(message.nackRepeated);
        }
        if (message.plis !== 0) {
          writer.uint32(216).uint32(message.plis);
        }
        if (message.lastPli !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.lastPli), writer.uint32(226).fork()).ldelim();
        }
        if (message.firs !== 0) {
          writer.uint32(232).uint32(message.firs);
        }
        if (message.lastFir !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.lastFir), writer.uint32(242).fork()).ldelim();
        }
        if (message.rttCurrent !== 0) {
          writer.uint32(248).uint32(message.rttCurrent);
        }
        if (message.rttMax !== 0) {
          writer.uint32(256).uint32(message.rttMax);
        }
        if (message.keyFrames !== 0) {
          writer.uint32(264).uint32(message.keyFrames);
        }
        if (message.lastKeyFrame !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.lastKeyFrame), writer.uint32(274).fork()).ldelim();
        }
        if (message.layerLockPlis !== 0) {
          writer.uint32(280).uint32(message.layerLockPlis);
        }
        if (message.lastLayerLockPli !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.lastLayerLockPli), writer.uint32(290).fork()).ldelim();
        }
        if (message.sampleRate !== 0) {
          writer.uint32(337).double(message.sampleRate);
        }
        if (message.driftMs !== 0) {
          writer.uint32(345).double(message.driftMs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTPStats();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.startTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 2:
              message.endTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.duration = reader.double();
              break;
            case 4:
              message.packets = reader.uint32();
              break;
            case 5:
              message.packetRate = reader.double();
              break;
            case 6:
              message.bytes = longToNumber(reader.uint64());
              break;
            case 39:
              message.headerBytes = longToNumber(reader.uint64());
              break;
            case 7:
              message.bitrate = reader.double();
              break;
            case 8:
              message.packetsLost = reader.uint32();
              break;
            case 9:
              message.packetLossRate = reader.double();
              break;
            case 10:
              message.packetLossPercentage = reader.float();
              break;
            case 11:
              message.packetsDuplicate = reader.uint32();
              break;
            case 12:
              message.packetDuplicateRate = reader.double();
              break;
            case 13:
              message.bytesDuplicate = longToNumber(reader.uint64());
              break;
            case 40:
              message.headerBytesDuplicate = longToNumber(reader.uint64());
              break;
            case 14:
              message.bitrateDuplicate = reader.double();
              break;
            case 15:
              message.packetsPadding = reader.uint32();
              break;
            case 16:
              message.packetPaddingRate = reader.double();
              break;
            case 17:
              message.bytesPadding = longToNumber(reader.uint64());
              break;
            case 41:
              message.headerBytesPadding = longToNumber(reader.uint64());
              break;
            case 18:
              message.bitratePadding = reader.double();
              break;
            case 19:
              message.packetsOutOfOrder = reader.uint32();
              break;
            case 20:
              message.frames = reader.uint32();
              break;
            case 21:
              message.frameRate = reader.double();
              break;
            case 22:
              message.jitterCurrent = reader.double();
              break;
            case 23:
              message.jitterMax = reader.double();
              break;
            case 24:
              const entry24 = exports2.RTPStats_GapHistogramEntry.decode(reader, reader.uint32());
              if (entry24.value !== void 0) {
                message.gapHistogram[entry24.key] = entry24.value;
              }
              break;
            case 25:
              message.nacks = reader.uint32();
              break;
            case 37:
              message.nackAcks = reader.uint32();
              break;
            case 26:
              message.nackMisses = reader.uint32();
              break;
            case 38:
              message.nackRepeated = reader.uint32();
              break;
            case 27:
              message.plis = reader.uint32();
              break;
            case 28:
              message.lastPli = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 29:
              message.firs = reader.uint32();
              break;
            case 30:
              message.lastFir = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 31:
              message.rttCurrent = reader.uint32();
              break;
            case 32:
              message.rttMax = reader.uint32();
              break;
            case 33:
              message.keyFrames = reader.uint32();
              break;
            case 34:
              message.lastKeyFrame = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 35:
              message.layerLockPlis = reader.uint32();
              break;
            case 36:
              message.lastLayerLockPli = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 42:
              message.sampleRate = reader.double();
              break;
            case 43:
              message.driftMs = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : void 0,
          endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : void 0,
          duration: isSet(object.duration) ? Number(object.duration) : 0,
          packets: isSet(object.packets) ? Number(object.packets) : 0,
          packetRate: isSet(object.packetRate) ? Number(object.packetRate) : 0,
          bytes: isSet(object.bytes) ? Number(object.bytes) : 0,
          headerBytes: isSet(object.headerBytes) ? Number(object.headerBytes) : 0,
          bitrate: isSet(object.bitrate) ? Number(object.bitrate) : 0,
          packetsLost: isSet(object.packetsLost) ? Number(object.packetsLost) : 0,
          packetLossRate: isSet(object.packetLossRate) ? Number(object.packetLossRate) : 0,
          packetLossPercentage: isSet(object.packetLossPercentage) ? Number(object.packetLossPercentage) : 0,
          packetsDuplicate: isSet(object.packetsDuplicate) ? Number(object.packetsDuplicate) : 0,
          packetDuplicateRate: isSet(object.packetDuplicateRate) ? Number(object.packetDuplicateRate) : 0,
          bytesDuplicate: isSet(object.bytesDuplicate) ? Number(object.bytesDuplicate) : 0,
          headerBytesDuplicate: isSet(object.headerBytesDuplicate) ? Number(object.headerBytesDuplicate) : 0,
          bitrateDuplicate: isSet(object.bitrateDuplicate) ? Number(object.bitrateDuplicate) : 0,
          packetsPadding: isSet(object.packetsPadding) ? Number(object.packetsPadding) : 0,
          packetPaddingRate: isSet(object.packetPaddingRate) ? Number(object.packetPaddingRate) : 0,
          bytesPadding: isSet(object.bytesPadding) ? Number(object.bytesPadding) : 0,
          headerBytesPadding: isSet(object.headerBytesPadding) ? Number(object.headerBytesPadding) : 0,
          bitratePadding: isSet(object.bitratePadding) ? Number(object.bitratePadding) : 0,
          packetsOutOfOrder: isSet(object.packetsOutOfOrder) ? Number(object.packetsOutOfOrder) : 0,
          frames: isSet(object.frames) ? Number(object.frames) : 0,
          frameRate: isSet(object.frameRate) ? Number(object.frameRate) : 0,
          jitterCurrent: isSet(object.jitterCurrent) ? Number(object.jitterCurrent) : 0,
          jitterMax: isSet(object.jitterMax) ? Number(object.jitterMax) : 0,
          gapHistogram: isObject(object.gapHistogram) ? Object.entries(object.gapHistogram).reduce((acc, [key, value]) => {
            acc[Number(key)] = Number(value);
            return acc;
          }, {}) : {},
          nacks: isSet(object.nacks) ? Number(object.nacks) : 0,
          nackAcks: isSet(object.nackAcks) ? Number(object.nackAcks) : 0,
          nackMisses: isSet(object.nackMisses) ? Number(object.nackMisses) : 0,
          nackRepeated: isSet(object.nackRepeated) ? Number(object.nackRepeated) : 0,
          plis: isSet(object.plis) ? Number(object.plis) : 0,
          lastPli: isSet(object.lastPli) ? fromJsonTimestamp(object.lastPli) : void 0,
          firs: isSet(object.firs) ? Number(object.firs) : 0,
          lastFir: isSet(object.lastFir) ? fromJsonTimestamp(object.lastFir) : void 0,
          rttCurrent: isSet(object.rttCurrent) ? Number(object.rttCurrent) : 0,
          rttMax: isSet(object.rttMax) ? Number(object.rttMax) : 0,
          keyFrames: isSet(object.keyFrames) ? Number(object.keyFrames) : 0,
          lastKeyFrame: isSet(object.lastKeyFrame) ? fromJsonTimestamp(object.lastKeyFrame) : void 0,
          layerLockPlis: isSet(object.layerLockPlis) ? Number(object.layerLockPlis) : 0,
          lastLayerLockPli: isSet(object.lastLayerLockPli) ? fromJsonTimestamp(object.lastLayerLockPli) : void 0,
          sampleRate: isSet(object.sampleRate) ? Number(object.sampleRate) : 0,
          driftMs: isSet(object.driftMs) ? Number(object.driftMs) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.startTime !== void 0 && (obj.startTime = message.startTime.toISOString());
        message.endTime !== void 0 && (obj.endTime = message.endTime.toISOString());
        message.duration !== void 0 && (obj.duration = message.duration);
        message.packets !== void 0 && (obj.packets = Math.round(message.packets));
        message.packetRate !== void 0 && (obj.packetRate = message.packetRate);
        message.bytes !== void 0 && (obj.bytes = Math.round(message.bytes));
        message.headerBytes !== void 0 && (obj.headerBytes = Math.round(message.headerBytes));
        message.bitrate !== void 0 && (obj.bitrate = message.bitrate);
        message.packetsLost !== void 0 && (obj.packetsLost = Math.round(message.packetsLost));
        message.packetLossRate !== void 0 && (obj.packetLossRate = message.packetLossRate);
        message.packetLossPercentage !== void 0 && (obj.packetLossPercentage = message.packetLossPercentage);
        message.packetsDuplicate !== void 0 && (obj.packetsDuplicate = Math.round(message.packetsDuplicate));
        message.packetDuplicateRate !== void 0 && (obj.packetDuplicateRate = message.packetDuplicateRate);
        message.bytesDuplicate !== void 0 && (obj.bytesDuplicate = Math.round(message.bytesDuplicate));
        message.headerBytesDuplicate !== void 0 && (obj.headerBytesDuplicate = Math.round(message.headerBytesDuplicate));
        message.bitrateDuplicate !== void 0 && (obj.bitrateDuplicate = message.bitrateDuplicate);
        message.packetsPadding !== void 0 && (obj.packetsPadding = Math.round(message.packetsPadding));
        message.packetPaddingRate !== void 0 && (obj.packetPaddingRate = message.packetPaddingRate);
        message.bytesPadding !== void 0 && (obj.bytesPadding = Math.round(message.bytesPadding));
        message.headerBytesPadding !== void 0 && (obj.headerBytesPadding = Math.round(message.headerBytesPadding));
        message.bitratePadding !== void 0 && (obj.bitratePadding = message.bitratePadding);
        message.packetsOutOfOrder !== void 0 && (obj.packetsOutOfOrder = Math.round(message.packetsOutOfOrder));
        message.frames !== void 0 && (obj.frames = Math.round(message.frames));
        message.frameRate !== void 0 && (obj.frameRate = message.frameRate);
        message.jitterCurrent !== void 0 && (obj.jitterCurrent = message.jitterCurrent);
        message.jitterMax !== void 0 && (obj.jitterMax = message.jitterMax);
        obj.gapHistogram = {};
        if (message.gapHistogram) {
          Object.entries(message.gapHistogram).forEach(([k, v]) => {
            obj.gapHistogram[k] = Math.round(v);
          });
        }
        message.nacks !== void 0 && (obj.nacks = Math.round(message.nacks));
        message.nackAcks !== void 0 && (obj.nackAcks = Math.round(message.nackAcks));
        message.nackMisses !== void 0 && (obj.nackMisses = Math.round(message.nackMisses));
        message.nackRepeated !== void 0 && (obj.nackRepeated = Math.round(message.nackRepeated));
        message.plis !== void 0 && (obj.plis = Math.round(message.plis));
        message.lastPli !== void 0 && (obj.lastPli = message.lastPli.toISOString());
        message.firs !== void 0 && (obj.firs = Math.round(message.firs));
        message.lastFir !== void 0 && (obj.lastFir = message.lastFir.toISOString());
        message.rttCurrent !== void 0 && (obj.rttCurrent = Math.round(message.rttCurrent));
        message.rttMax !== void 0 && (obj.rttMax = Math.round(message.rttMax));
        message.keyFrames !== void 0 && (obj.keyFrames = Math.round(message.keyFrames));
        message.lastKeyFrame !== void 0 && (obj.lastKeyFrame = message.lastKeyFrame.toISOString());
        message.layerLockPlis !== void 0 && (obj.layerLockPlis = Math.round(message.layerLockPlis));
        message.lastLayerLockPli !== void 0 && (obj.lastLayerLockPli = message.lastLayerLockPli.toISOString());
        message.sampleRate !== void 0 && (obj.sampleRate = message.sampleRate);
        message.driftMs !== void 0 && (obj.driftMs = message.driftMs);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18;
        const message = createBaseRTPStats();
        message.startTime = (_a = object.startTime) !== null && _a !== void 0 ? _a : void 0;
        message.endTime = (_b = object.endTime) !== null && _b !== void 0 ? _b : void 0;
        message.duration = (_c = object.duration) !== null && _c !== void 0 ? _c : 0;
        message.packets = (_d = object.packets) !== null && _d !== void 0 ? _d : 0;
        message.packetRate = (_e = object.packetRate) !== null && _e !== void 0 ? _e : 0;
        message.bytes = (_f = object.bytes) !== null && _f !== void 0 ? _f : 0;
        message.headerBytes = (_g = object.headerBytes) !== null && _g !== void 0 ? _g : 0;
        message.bitrate = (_h = object.bitrate) !== null && _h !== void 0 ? _h : 0;
        message.packetsLost = (_j = object.packetsLost) !== null && _j !== void 0 ? _j : 0;
        message.packetLossRate = (_k = object.packetLossRate) !== null && _k !== void 0 ? _k : 0;
        message.packetLossPercentage = (_l = object.packetLossPercentage) !== null && _l !== void 0 ? _l : 0;
        message.packetsDuplicate = (_m = object.packetsDuplicate) !== null && _m !== void 0 ? _m : 0;
        message.packetDuplicateRate = (_o = object.packetDuplicateRate) !== null && _o !== void 0 ? _o : 0;
        message.bytesDuplicate = (_p = object.bytesDuplicate) !== null && _p !== void 0 ? _p : 0;
        message.headerBytesDuplicate = (_q = object.headerBytesDuplicate) !== null && _q !== void 0 ? _q : 0;
        message.bitrateDuplicate = (_r = object.bitrateDuplicate) !== null && _r !== void 0 ? _r : 0;
        message.packetsPadding = (_s = object.packetsPadding) !== null && _s !== void 0 ? _s : 0;
        message.packetPaddingRate = (_t = object.packetPaddingRate) !== null && _t !== void 0 ? _t : 0;
        message.bytesPadding = (_u = object.bytesPadding) !== null && _u !== void 0 ? _u : 0;
        message.headerBytesPadding = (_v = object.headerBytesPadding) !== null && _v !== void 0 ? _v : 0;
        message.bitratePadding = (_w = object.bitratePadding) !== null && _w !== void 0 ? _w : 0;
        message.packetsOutOfOrder = (_x = object.packetsOutOfOrder) !== null && _x !== void 0 ? _x : 0;
        message.frames = (_y = object.frames) !== null && _y !== void 0 ? _y : 0;
        message.frameRate = (_z = object.frameRate) !== null && _z !== void 0 ? _z : 0;
        message.jitterCurrent = (_0 = object.jitterCurrent) !== null && _0 !== void 0 ? _0 : 0;
        message.jitterMax = (_1 = object.jitterMax) !== null && _1 !== void 0 ? _1 : 0;
        message.gapHistogram = Object.entries((_2 = object.gapHistogram) !== null && _2 !== void 0 ? _2 : {}).reduce((acc, [key, value]) => {
          if (value !== void 0) {
            acc[Number(key)] = Number(value);
          }
          return acc;
        }, {});
        message.nacks = (_3 = object.nacks) !== null && _3 !== void 0 ? _3 : 0;
        message.nackAcks = (_4 = object.nackAcks) !== null && _4 !== void 0 ? _4 : 0;
        message.nackMisses = (_5 = object.nackMisses) !== null && _5 !== void 0 ? _5 : 0;
        message.nackRepeated = (_6 = object.nackRepeated) !== null && _6 !== void 0 ? _6 : 0;
        message.plis = (_7 = object.plis) !== null && _7 !== void 0 ? _7 : 0;
        message.lastPli = (_8 = object.lastPli) !== null && _8 !== void 0 ? _8 : void 0;
        message.firs = (_9 = object.firs) !== null && _9 !== void 0 ? _9 : 0;
        message.lastFir = (_10 = object.lastFir) !== null && _10 !== void 0 ? _10 : void 0;
        message.rttCurrent = (_11 = object.rttCurrent) !== null && _11 !== void 0 ? _11 : 0;
        message.rttMax = (_12 = object.rttMax) !== null && _12 !== void 0 ? _12 : 0;
        message.keyFrames = (_13 = object.keyFrames) !== null && _13 !== void 0 ? _13 : 0;
        message.lastKeyFrame = (_14 = object.lastKeyFrame) !== null && _14 !== void 0 ? _14 : void 0;
        message.layerLockPlis = (_15 = object.layerLockPlis) !== null && _15 !== void 0 ? _15 : 0;
        message.lastLayerLockPli = (_16 = object.lastLayerLockPli) !== null && _16 !== void 0 ? _16 : void 0;
        message.sampleRate = (_17 = object.sampleRate) !== null && _17 !== void 0 ? _17 : 0;
        message.driftMs = (_18 = object.driftMs) !== null && _18 !== void 0 ? _18 : 0;
        return message;
      }
    };
    function createBaseRTPStats_GapHistogramEntry() {
      return { key: 0, value: 0 };
    }
    exports2.RTPStats_GapHistogramEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== 0) {
          writer.uint32(8).int32(message.key);
        }
        if (message.value !== 0) {
          writer.uint32(16).uint32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTPStats_GapHistogramEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.int32();
              break;
            case 2:
              message.value = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet(object.key) ? Number(object.key) : 0, value: isSet(object.value) ? Number(object.value) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = Math.round(message.key));
        message.value !== void 0 && (obj.value = Math.round(message.value));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRTPStats_GapHistogramEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseTimedVersion() {
      return { unixMicro: 0, ticks: 0 };
    }
    exports2.TimedVersion = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unixMicro !== 0) {
          writer.uint32(8).int64(message.unixMicro);
        }
        if (message.ticks !== 0) {
          writer.uint32(16).int32(message.ticks);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimedVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unixMicro = longToNumber(reader.int64());
              break;
            case 2:
              message.ticks = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unixMicro: isSet(object.unixMicro) ? Number(object.unixMicro) : 0,
          ticks: isSet(object.ticks) ? Number(object.ticks) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.unixMicro !== void 0 && (obj.unixMicro = Math.round(message.unixMicro));
        message.ticks !== void 0 && (obj.ticks = Math.round(message.ticks));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTimedVersion();
        message.unixMicro = (_a = object.unixMicro) !== null && _a !== void 0 ? _a : 0;
        message.ticks = (_b = object.ticks) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function toTimestamp(date) {
      const seconds = date.getTime() / 1e3;
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function longToNumber(long) {
      if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
      }
      return long.toNumber();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/livekit-server-sdk/dist/proto/livekit_egress.js
var require_livekit_egress = __commonJS({
  "node_modules/livekit-server-sdk/dist/proto/livekit_egress.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoTrackEgress = exports2.SegmentsInfo = exports2.FileInfo = exports2.StreamInfo = exports2.StreamInfoList = exports2.EgressInfo = exports2.StopEgressRequest = exports2.ListEgressResponse = exports2.ListEgressRequest = exports2.UpdateStreamRequest = exports2.UpdateLayoutRequest = exports2.EncodingOptions = exports2.StreamOutput = exports2.AliOSSUpload = exports2.AzureBlobUpload = exports2.GCPUpload = exports2.S3Upload_MetadataEntry = exports2.S3Upload = exports2.DirectFileOutput = exports2.SegmentedFileOutput = exports2.EncodedFileOutput = exports2.TrackEgressRequest = exports2.TrackCompositeEgressRequest = exports2.WebEgressRequest = exports2.RoomCompositeEgressRequest = exports2.streamInfo_StatusToJSON = exports2.streamInfo_StatusFromJSON = exports2.StreamInfo_Status = exports2.egressStatusToJSON = exports2.egressStatusFromJSON = exports2.EgressStatus = exports2.encodingOptionsPresetToJSON = exports2.encodingOptionsPresetFromJSON = exports2.EncodingOptionsPreset = exports2.streamProtocolToJSON = exports2.streamProtocolFromJSON = exports2.StreamProtocol = exports2.segmentedFileSuffixToJSON = exports2.segmentedFileSuffixFromJSON = exports2.SegmentedFileSuffix = exports2.segmentedFileProtocolToJSON = exports2.segmentedFileProtocolFromJSON = exports2.SegmentedFileProtocol = exports2.encodedFileTypeToJSON = exports2.encodedFileTypeFromJSON = exports2.EncodedFileType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_umd());
    var minimal_1 = __importDefault(require_minimal2());
    var livekit_models_1 = require_livekit_models();
    exports2.protobufPackage = "livekit";
    var EncodedFileType;
    (function(EncodedFileType2) {
      EncodedFileType2[EncodedFileType2["DEFAULT_FILETYPE"] = 0] = "DEFAULT_FILETYPE";
      EncodedFileType2[EncodedFileType2["MP4"] = 1] = "MP4";
      EncodedFileType2[EncodedFileType2["OGG"] = 2] = "OGG";
      EncodedFileType2[EncodedFileType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EncodedFileType = exports2.EncodedFileType || (exports2.EncodedFileType = {}));
    function encodedFileTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "DEFAULT_FILETYPE":
          return EncodedFileType.DEFAULT_FILETYPE;
        case 1:
        case "MP4":
          return EncodedFileType.MP4;
        case 2:
        case "OGG":
          return EncodedFileType.OGG;
        case -1:
        case "UNRECOGNIZED":
        default:
          return EncodedFileType.UNRECOGNIZED;
      }
    }
    exports2.encodedFileTypeFromJSON = encodedFileTypeFromJSON;
    function encodedFileTypeToJSON(object) {
      switch (object) {
        case EncodedFileType.DEFAULT_FILETYPE:
          return "DEFAULT_FILETYPE";
        case EncodedFileType.MP4:
          return "MP4";
        case EncodedFileType.OGG:
          return "OGG";
        case EncodedFileType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.encodedFileTypeToJSON = encodedFileTypeToJSON;
    var SegmentedFileProtocol;
    (function(SegmentedFileProtocol2) {
      SegmentedFileProtocol2[SegmentedFileProtocol2["DEFAULT_SEGMENTED_FILE_PROTOCOL"] = 0] = "DEFAULT_SEGMENTED_FILE_PROTOCOL";
      SegmentedFileProtocol2[SegmentedFileProtocol2["HLS_PROTOCOL"] = 1] = "HLS_PROTOCOL";
      SegmentedFileProtocol2[SegmentedFileProtocol2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SegmentedFileProtocol = exports2.SegmentedFileProtocol || (exports2.SegmentedFileProtocol = {}));
    function segmentedFileProtocolFromJSON(object) {
      switch (object) {
        case 0:
        case "DEFAULT_SEGMENTED_FILE_PROTOCOL":
          return SegmentedFileProtocol.DEFAULT_SEGMENTED_FILE_PROTOCOL;
        case 1:
        case "HLS_PROTOCOL":
          return SegmentedFileProtocol.HLS_PROTOCOL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SegmentedFileProtocol.UNRECOGNIZED;
      }
    }
    exports2.segmentedFileProtocolFromJSON = segmentedFileProtocolFromJSON;
    function segmentedFileProtocolToJSON(object) {
      switch (object) {
        case SegmentedFileProtocol.DEFAULT_SEGMENTED_FILE_PROTOCOL:
          return "DEFAULT_SEGMENTED_FILE_PROTOCOL";
        case SegmentedFileProtocol.HLS_PROTOCOL:
          return "HLS_PROTOCOL";
        case SegmentedFileProtocol.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.segmentedFileProtocolToJSON = segmentedFileProtocolToJSON;
    var SegmentedFileSuffix;
    (function(SegmentedFileSuffix2) {
      SegmentedFileSuffix2[SegmentedFileSuffix2["INDEX"] = 0] = "INDEX";
      SegmentedFileSuffix2[SegmentedFileSuffix2["TIMESTAMP"] = 1] = "TIMESTAMP";
      SegmentedFileSuffix2[SegmentedFileSuffix2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SegmentedFileSuffix = exports2.SegmentedFileSuffix || (exports2.SegmentedFileSuffix = {}));
    function segmentedFileSuffixFromJSON(object) {
      switch (object) {
        case 0:
        case "INDEX":
          return SegmentedFileSuffix.INDEX;
        case 1:
        case "TIMESTAMP":
          return SegmentedFileSuffix.TIMESTAMP;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SegmentedFileSuffix.UNRECOGNIZED;
      }
    }
    exports2.segmentedFileSuffixFromJSON = segmentedFileSuffixFromJSON;
    function segmentedFileSuffixToJSON(object) {
      switch (object) {
        case SegmentedFileSuffix.INDEX:
          return "INDEX";
        case SegmentedFileSuffix.TIMESTAMP:
          return "TIMESTAMP";
        case SegmentedFileSuffix.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.segmentedFileSuffixToJSON = segmentedFileSuffixToJSON;
    var StreamProtocol;
    (function(StreamProtocol2) {
      StreamProtocol2[StreamProtocol2["DEFAULT_PROTOCOL"] = 0] = "DEFAULT_PROTOCOL";
      StreamProtocol2[StreamProtocol2["RTMP"] = 1] = "RTMP";
      StreamProtocol2[StreamProtocol2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(StreamProtocol = exports2.StreamProtocol || (exports2.StreamProtocol = {}));
    function streamProtocolFromJSON(object) {
      switch (object) {
        case 0:
        case "DEFAULT_PROTOCOL":
          return StreamProtocol.DEFAULT_PROTOCOL;
        case 1:
        case "RTMP":
          return StreamProtocol.RTMP;
        case -1:
        case "UNRECOGNIZED":
        default:
          return StreamProtocol.UNRECOGNIZED;
      }
    }
    exports2.streamProtocolFromJSON = streamProtocolFromJSON;
    function streamProtocolToJSON(object) {
      switch (object) {
        case StreamProtocol.DEFAULT_PROTOCOL:
          return "DEFAULT_PROTOCOL";
        case StreamProtocol.RTMP:
          return "RTMP";
        case StreamProtocol.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.streamProtocolToJSON = streamProtocolToJSON;
    var EncodingOptionsPreset;
    (function(EncodingOptionsPreset2) {
      EncodingOptionsPreset2[EncodingOptionsPreset2["H264_720P_30"] = 0] = "H264_720P_30";
      EncodingOptionsPreset2[EncodingOptionsPreset2["H264_720P_60"] = 1] = "H264_720P_60";
      EncodingOptionsPreset2[EncodingOptionsPreset2["H264_1080P_30"] = 2] = "H264_1080P_30";
      EncodingOptionsPreset2[EncodingOptionsPreset2["H264_1080P_60"] = 3] = "H264_1080P_60";
      EncodingOptionsPreset2[EncodingOptionsPreset2["PORTRAIT_H264_720P_30"] = 4] = "PORTRAIT_H264_720P_30";
      EncodingOptionsPreset2[EncodingOptionsPreset2["PORTRAIT_H264_720P_60"] = 5] = "PORTRAIT_H264_720P_60";
      EncodingOptionsPreset2[EncodingOptionsPreset2["PORTRAIT_H264_1080P_30"] = 6] = "PORTRAIT_H264_1080P_30";
      EncodingOptionsPreset2[EncodingOptionsPreset2["PORTRAIT_H264_1080P_60"] = 7] = "PORTRAIT_H264_1080P_60";
      EncodingOptionsPreset2[EncodingOptionsPreset2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EncodingOptionsPreset = exports2.EncodingOptionsPreset || (exports2.EncodingOptionsPreset = {}));
    function encodingOptionsPresetFromJSON(object) {
      switch (object) {
        case 0:
        case "H264_720P_30":
          return EncodingOptionsPreset.H264_720P_30;
        case 1:
        case "H264_720P_60":
          return EncodingOptionsPreset.H264_720P_60;
        case 2:
        case "H264_1080P_30":
          return EncodingOptionsPreset.H264_1080P_30;
        case 3:
        case "H264_1080P_60":
          return EncodingOptionsPreset.H264_1080P_60;
        case 4:
        case "PORTRAIT_H264_720P_30":
          return EncodingOptionsPreset.PORTRAIT_H264_720P_30;
        case 5:
        case "PORTRAIT_H264_720P_60":
          return EncodingOptionsPreset.PORTRAIT_H264_720P_60;
        case 6:
        case "PORTRAIT_H264_1080P_30":
          return EncodingOptionsPreset.PORTRAIT_H264_1080P_30;
        case 7:
        case "PORTRAIT_H264_1080P_60":
          return EncodingOptionsPreset.PORTRAIT_H264_1080P_60;
        case -1:
        case "UNRECOGNIZED":
        default:
          return EncodingOptionsPreset.UNRECOGNIZED;
      }
    }
    exports2.encodingOptionsPresetFromJSON = encodingOptionsPresetFromJSON;
    function encodingOptionsPresetToJSON(object) {
      switch (object) {
        case EncodingOptionsPreset.H264_720P_30:
          return "H264_720P_30";
        case EncodingOptionsPreset.H264_720P_60:
          return "H264_720P_60";
        case EncodingOptionsPreset.H264_1080P_30:
          return "H264_1080P_30";
        case EncodingOptionsPreset.H264_1080P_60:
          return "H264_1080P_60";
        case EncodingOptionsPreset.PORTRAIT_H264_720P_30:
          return "PORTRAIT_H264_720P_30";
        case EncodingOptionsPreset.PORTRAIT_H264_720P_60:
          return "PORTRAIT_H264_720P_60";
        case EncodingOptionsPreset.PORTRAIT_H264_1080P_30:
          return "PORTRAIT_H264_1080P_30";
        case EncodingOptionsPreset.PORTRAIT_H264_1080P_60:
          return "PORTRAIT_H264_1080P_60";
        case EncodingOptionsPreset.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.encodingOptionsPresetToJSON = encodingOptionsPresetToJSON;
    var EgressStatus;
    (function(EgressStatus2) {
      EgressStatus2[EgressStatus2["EGRESS_STARTING"] = 0] = "EGRESS_STARTING";
      EgressStatus2[EgressStatus2["EGRESS_ACTIVE"] = 1] = "EGRESS_ACTIVE";
      EgressStatus2[EgressStatus2["EGRESS_ENDING"] = 2] = "EGRESS_ENDING";
      EgressStatus2[EgressStatus2["EGRESS_COMPLETE"] = 3] = "EGRESS_COMPLETE";
      EgressStatus2[EgressStatus2["EGRESS_FAILED"] = 4] = "EGRESS_FAILED";
      EgressStatus2[EgressStatus2["EGRESS_ABORTED"] = 5] = "EGRESS_ABORTED";
      EgressStatus2[EgressStatus2["EGRESS_LIMIT_REACHED"] = 6] = "EGRESS_LIMIT_REACHED";
      EgressStatus2[EgressStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EgressStatus = exports2.EgressStatus || (exports2.EgressStatus = {}));
    function egressStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "EGRESS_STARTING":
          return EgressStatus.EGRESS_STARTING;
        case 1:
        case "EGRESS_ACTIVE":
          return EgressStatus.EGRESS_ACTIVE;
        case 2:
        case "EGRESS_ENDING":
          return EgressStatus.EGRESS_ENDING;
        case 3:
        case "EGRESS_COMPLETE":
          return EgressStatus.EGRESS_COMPLETE;
        case 4:
        case "EGRESS_FAILED":
          return EgressStatus.EGRESS_FAILED;
        case 5:
        case "EGRESS_ABORTED":
          return EgressStatus.EGRESS_ABORTED;
        case 6:
        case "EGRESS_LIMIT_REACHED":
          return EgressStatus.EGRESS_LIMIT_REACHED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return EgressStatus.UNRECOGNIZED;
      }
    }
    exports2.egressStatusFromJSON = egressStatusFromJSON;
    function egressStatusToJSON(object) {
      switch (object) {
        case EgressStatus.EGRESS_STARTING:
          return "EGRESS_STARTING";
        case EgressStatus.EGRESS_ACTIVE:
          return "EGRESS_ACTIVE";
        case EgressStatus.EGRESS_ENDING:
          return "EGRESS_ENDING";
        case EgressStatus.EGRESS_COMPLETE:
          return "EGRESS_COMPLETE";
        case EgressStatus.EGRESS_FAILED:
          return "EGRESS_FAILED";
        case EgressStatus.EGRESS_ABORTED:
          return "EGRESS_ABORTED";
        case EgressStatus.EGRESS_LIMIT_REACHED:
          return "EGRESS_LIMIT_REACHED";
        case EgressStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.egressStatusToJSON = egressStatusToJSON;
    var StreamInfo_Status;
    (function(StreamInfo_Status2) {
      StreamInfo_Status2[StreamInfo_Status2["ACTIVE"] = 0] = "ACTIVE";
      StreamInfo_Status2[StreamInfo_Status2["FINISHED"] = 1] = "FINISHED";
      StreamInfo_Status2[StreamInfo_Status2["FAILED"] = 2] = "FAILED";
      StreamInfo_Status2[StreamInfo_Status2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(StreamInfo_Status = exports2.StreamInfo_Status || (exports2.StreamInfo_Status = {}));
    function streamInfo_StatusFromJSON(object) {
      switch (object) {
        case 0:
        case "ACTIVE":
          return StreamInfo_Status.ACTIVE;
        case 1:
        case "FINISHED":
          return StreamInfo_Status.FINISHED;
        case 2:
        case "FAILED":
          return StreamInfo_Status.FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return StreamInfo_Status.UNRECOGNIZED;
      }
    }
    exports2.streamInfo_StatusFromJSON = streamInfo_StatusFromJSON;
    function streamInfo_StatusToJSON(object) {
      switch (object) {
        case StreamInfo_Status.ACTIVE:
          return "ACTIVE";
        case StreamInfo_Status.FINISHED:
          return "FINISHED";
        case StreamInfo_Status.FAILED:
          return "FAILED";
        case StreamInfo_Status.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.streamInfo_StatusToJSON = streamInfo_StatusToJSON;
    function createBaseRoomCompositeEgressRequest() {
      return {
        roomName: "",
        layout: "",
        audioOnly: false,
        videoOnly: false,
        customBaseUrl: "",
        file: void 0,
        stream: void 0,
        segments: void 0,
        preset: void 0,
        advanced: void 0,
        fileOutputs: [],
        streamOutputs: [],
        segmentOutputs: []
      };
    }
    exports2.RoomCompositeEgressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(10).string(message.roomName);
        }
        if (message.layout !== void 0 && message.layout !== "") {
          writer.uint32(18).string(message.layout);
        }
        if (message.audioOnly === true) {
          writer.uint32(24).bool(message.audioOnly);
        }
        if (message.videoOnly === true) {
          writer.uint32(32).bool(message.videoOnly);
        }
        if (message.customBaseUrl !== void 0 && message.customBaseUrl !== "") {
          writer.uint32(42).string(message.customBaseUrl);
        }
        if (message.file !== void 0) {
          exports2.EncodedFileOutput.encode(message.file, writer.uint32(50).fork()).ldelim();
        }
        if (message.stream !== void 0) {
          exports2.StreamOutput.encode(message.stream, writer.uint32(58).fork()).ldelim();
        }
        if (message.segments !== void 0) {
          exports2.SegmentedFileOutput.encode(message.segments, writer.uint32(82).fork()).ldelim();
        }
        if (message.preset !== void 0) {
          writer.uint32(64).int32(message.preset);
        }
        if (message.advanced !== void 0) {
          exports2.EncodingOptions.encode(message.advanced, writer.uint32(74).fork()).ldelim();
        }
        if (message.fileOutputs !== void 0 && message.fileOutputs.length !== 0) {
          for (const v of message.fileOutputs) {
            exports2.EncodedFileOutput.encode(v, writer.uint32(90).fork()).ldelim();
          }
        }
        if (message.streamOutputs !== void 0 && message.streamOutputs.length !== 0) {
          for (const v of message.streamOutputs) {
            exports2.StreamOutput.encode(v, writer.uint32(98).fork()).ldelim();
          }
        }
        if (message.segmentOutputs !== void 0 && message.segmentOutputs.length !== 0) {
          for (const v of message.segmentOutputs) {
            exports2.SegmentedFileOutput.encode(v, writer.uint32(106).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRoomCompositeEgressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.roomName = reader.string();
              break;
            case 2:
              message.layout = reader.string();
              break;
            case 3:
              message.audioOnly = reader.bool();
              break;
            case 4:
              message.videoOnly = reader.bool();
              break;
            case 5:
              message.customBaseUrl = reader.string();
              break;
            case 6:
              message.file = exports2.EncodedFileOutput.decode(reader, reader.uint32());
              break;
            case 7:
              message.stream = exports2.StreamOutput.decode(reader, reader.uint32());
              break;
            case 10:
              message.segments = exports2.SegmentedFileOutput.decode(reader, reader.uint32());
              break;
            case 8:
              message.preset = reader.int32();
              break;
            case 9:
              message.advanced = exports2.EncodingOptions.decode(reader, reader.uint32());
              break;
            case 11:
              message.fileOutputs.push(exports2.EncodedFileOutput.decode(reader, reader.uint32()));
              break;
            case 12:
              message.streamOutputs.push(exports2.StreamOutput.decode(reader, reader.uint32()));
              break;
            case 13:
              message.segmentOutputs.push(exports2.SegmentedFileOutput.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          layout: isSet(object.layout) ? String(object.layout) : "",
          audioOnly: isSet(object.audioOnly) ? Boolean(object.audioOnly) : false,
          videoOnly: isSet(object.videoOnly) ? Boolean(object.videoOnly) : false,
          customBaseUrl: isSet(object.customBaseUrl) ? String(object.customBaseUrl) : "",
          file: isSet(object.file) ? exports2.EncodedFileOutput.fromJSON(object.file) : void 0,
          stream: isSet(object.stream) ? exports2.StreamOutput.fromJSON(object.stream) : void 0,
          segments: isSet(object.segments) ? exports2.SegmentedFileOutput.fromJSON(object.segments) : void 0,
          preset: isSet(object.preset) ? encodingOptionsPresetFromJSON(object.preset) : void 0,
          advanced: isSet(object.advanced) ? exports2.EncodingOptions.fromJSON(object.advanced) : void 0,
          fileOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.fileOutputs) ? object.fileOutputs.map((e) => exports2.EncodedFileOutput.fromJSON(e)) : [],
          streamOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.streamOutputs) ? object.streamOutputs.map((e) => exports2.StreamOutput.fromJSON(e)) : [],
          segmentOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.segmentOutputs) ? object.segmentOutputs.map((e) => exports2.SegmentedFileOutput.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.layout !== void 0 && (obj.layout = message.layout);
        message.audioOnly !== void 0 && (obj.audioOnly = message.audioOnly);
        message.videoOnly !== void 0 && (obj.videoOnly = message.videoOnly);
        message.customBaseUrl !== void 0 && (obj.customBaseUrl = message.customBaseUrl);
        message.file !== void 0 && (obj.file = message.file ? exports2.EncodedFileOutput.toJSON(message.file) : void 0);
        message.stream !== void 0 && (obj.stream = message.stream ? exports2.StreamOutput.toJSON(message.stream) : void 0);
        message.segments !== void 0 && (obj.segments = message.segments ? exports2.SegmentedFileOutput.toJSON(message.segments) : void 0);
        message.preset !== void 0 && (obj.preset = message.preset !== void 0 ? encodingOptionsPresetToJSON(message.preset) : void 0);
        message.advanced !== void 0 && (obj.advanced = message.advanced ? exports2.EncodingOptions.toJSON(message.advanced) : void 0);
        if (message.fileOutputs) {
          obj.fileOutputs = message.fileOutputs.map((e) => e ? exports2.EncodedFileOutput.toJSON(e) : void 0);
        } else {
          obj.fileOutputs = [];
        }
        if (message.streamOutputs) {
          obj.streamOutputs = message.streamOutputs.map((e) => e ? exports2.StreamOutput.toJSON(e) : void 0);
        } else {
          obj.streamOutputs = [];
        }
        if (message.segmentOutputs) {
          obj.segmentOutputs = message.segmentOutputs.map((e) => e ? exports2.SegmentedFileOutput.toJSON(e) : void 0);
        } else {
          obj.segmentOutputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseRoomCompositeEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.layout = (_b = object.layout) !== null && _b !== void 0 ? _b : "";
        message.audioOnly = (_c = object.audioOnly) !== null && _c !== void 0 ? _c : false;
        message.videoOnly = (_d = object.videoOnly) !== null && _d !== void 0 ? _d : false;
        message.customBaseUrl = (_e = object.customBaseUrl) !== null && _e !== void 0 ? _e : "";
        message.file = object.file !== void 0 && object.file !== null ? exports2.EncodedFileOutput.fromPartial(object.file) : void 0;
        message.stream = object.stream !== void 0 && object.stream !== null ? exports2.StreamOutput.fromPartial(object.stream) : void 0;
        message.segments = object.segments !== void 0 && object.segments !== null ? exports2.SegmentedFileOutput.fromPartial(object.segments) : void 0;
        message.preset = (_f = object.preset) !== null && _f !== void 0 ? _f : void 0;
        message.advanced = object.advanced !== void 0 && object.advanced !== null ? exports2.EncodingOptions.fromPartial(object.advanced) : void 0;
        message.fileOutputs = ((_g = object.fileOutputs) === null || _g === void 0 ? void 0 : _g.map((e) => exports2.EncodedFileOutput.fromPartial(e))) || [];
        message.streamOutputs = ((_h = object.streamOutputs) === null || _h === void 0 ? void 0 : _h.map((e) => exports2.StreamOutput.fromPartial(e))) || [];
        message.segmentOutputs = ((_j = object.segmentOutputs) === null || _j === void 0 ? void 0 : _j.map((e) => exports2.SegmentedFileOutput.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseWebEgressRequest() {
      return {
        url: "",
        audioOnly: false,
        videoOnly: false,
        awaitStartSignal: false,
        file: void 0,
        stream: void 0,
        segments: void 0,
        preset: void 0,
        advanced: void 0,
        fileOutputs: [],
        streamOutputs: [],
        segmentOutputs: []
      };
    }
    exports2.WebEgressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.url !== void 0 && message.url !== "") {
          writer.uint32(10).string(message.url);
        }
        if (message.audioOnly === true) {
          writer.uint32(16).bool(message.audioOnly);
        }
        if (message.videoOnly === true) {
          writer.uint32(24).bool(message.videoOnly);
        }
        if (message.awaitStartSignal === true) {
          writer.uint32(96).bool(message.awaitStartSignal);
        }
        if (message.file !== void 0) {
          exports2.EncodedFileOutput.encode(message.file, writer.uint32(34).fork()).ldelim();
        }
        if (message.stream !== void 0) {
          exports2.StreamOutput.encode(message.stream, writer.uint32(42).fork()).ldelim();
        }
        if (message.segments !== void 0) {
          exports2.SegmentedFileOutput.encode(message.segments, writer.uint32(50).fork()).ldelim();
        }
        if (message.preset !== void 0) {
          writer.uint32(56).int32(message.preset);
        }
        if (message.advanced !== void 0) {
          exports2.EncodingOptions.encode(message.advanced, writer.uint32(66).fork()).ldelim();
        }
        if (message.fileOutputs !== void 0 && message.fileOutputs.length !== 0) {
          for (const v of message.fileOutputs) {
            exports2.EncodedFileOutput.encode(v, writer.uint32(74).fork()).ldelim();
          }
        }
        if (message.streamOutputs !== void 0 && message.streamOutputs.length !== 0) {
          for (const v of message.streamOutputs) {
            exports2.StreamOutput.encode(v, writer.uint32(82).fork()).ldelim();
          }
        }
        if (message.segmentOutputs !== void 0 && message.segmentOutputs.length !== 0) {
          for (const v of message.segmentOutputs) {
            exports2.SegmentedFileOutput.encode(v, writer.uint32(90).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebEgressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.url = reader.string();
              break;
            case 2:
              message.audioOnly = reader.bool();
              break;
            case 3:
              message.videoOnly = reader.bool();
              break;
            case 12:
              message.awaitStartSignal = reader.bool();
              break;
            case 4:
              message.file = exports2.EncodedFileOutput.decode(reader, reader.uint32());
              break;
            case 5:
              message.stream = exports2.StreamOutput.decode(reader, reader.uint32());
              break;
            case 6:
              message.segments = exports2.SegmentedFileOutput.decode(reader, reader.uint32());
              break;
            case 7:
              message.preset = reader.int32();
              break;
            case 8:
              message.advanced = exports2.EncodingOptions.decode(reader, reader.uint32());
              break;
            case 9:
              message.fileOutputs.push(exports2.EncodedFileOutput.decode(reader, reader.uint32()));
              break;
            case 10:
              message.streamOutputs.push(exports2.StreamOutput.decode(reader, reader.uint32()));
              break;
            case 11:
              message.segmentOutputs.push(exports2.SegmentedFileOutput.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          url: isSet(object.url) ? String(object.url) : "",
          audioOnly: isSet(object.audioOnly) ? Boolean(object.audioOnly) : false,
          videoOnly: isSet(object.videoOnly) ? Boolean(object.videoOnly) : false,
          awaitStartSignal: isSet(object.awaitStartSignal) ? Boolean(object.awaitStartSignal) : false,
          file: isSet(object.file) ? exports2.EncodedFileOutput.fromJSON(object.file) : void 0,
          stream: isSet(object.stream) ? exports2.StreamOutput.fromJSON(object.stream) : void 0,
          segments: isSet(object.segments) ? exports2.SegmentedFileOutput.fromJSON(object.segments) : void 0,
          preset: isSet(object.preset) ? encodingOptionsPresetFromJSON(object.preset) : void 0,
          advanced: isSet(object.advanced) ? exports2.EncodingOptions.fromJSON(object.advanced) : void 0,
          fileOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.fileOutputs) ? object.fileOutputs.map((e) => exports2.EncodedFileOutput.fromJSON(e)) : [],
          streamOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.streamOutputs) ? object.streamOutputs.map((e) => exports2.StreamOutput.fromJSON(e)) : [],
          segmentOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.segmentOutputs) ? object.segmentOutputs.map((e) => exports2.SegmentedFileOutput.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.url !== void 0 && (obj.url = message.url);
        message.audioOnly !== void 0 && (obj.audioOnly = message.audioOnly);
        message.videoOnly !== void 0 && (obj.videoOnly = message.videoOnly);
        message.awaitStartSignal !== void 0 && (obj.awaitStartSignal = message.awaitStartSignal);
        message.file !== void 0 && (obj.file = message.file ? exports2.EncodedFileOutput.toJSON(message.file) : void 0);
        message.stream !== void 0 && (obj.stream = message.stream ? exports2.StreamOutput.toJSON(message.stream) : void 0);
        message.segments !== void 0 && (obj.segments = message.segments ? exports2.SegmentedFileOutput.toJSON(message.segments) : void 0);
        message.preset !== void 0 && (obj.preset = message.preset !== void 0 ? encodingOptionsPresetToJSON(message.preset) : void 0);
        message.advanced !== void 0 && (obj.advanced = message.advanced ? exports2.EncodingOptions.toJSON(message.advanced) : void 0);
        if (message.fileOutputs) {
          obj.fileOutputs = message.fileOutputs.map((e) => e ? exports2.EncodedFileOutput.toJSON(e) : void 0);
        } else {
          obj.fileOutputs = [];
        }
        if (message.streamOutputs) {
          obj.streamOutputs = message.streamOutputs.map((e) => e ? exports2.StreamOutput.toJSON(e) : void 0);
        } else {
          obj.streamOutputs = [];
        }
        if (message.segmentOutputs) {
          obj.segmentOutputs = message.segmentOutputs.map((e) => e ? exports2.SegmentedFileOutput.toJSON(e) : void 0);
        } else {
          obj.segmentOutputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseWebEgressRequest();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        message.audioOnly = (_b = object.audioOnly) !== null && _b !== void 0 ? _b : false;
        message.videoOnly = (_c = object.videoOnly) !== null && _c !== void 0 ? _c : false;
        message.awaitStartSignal = (_d = object.awaitStartSignal) !== null && _d !== void 0 ? _d : false;
        message.file = object.file !== void 0 && object.file !== null ? exports2.EncodedFileOutput.fromPartial(object.file) : void 0;
        message.stream = object.stream !== void 0 && object.stream !== null ? exports2.StreamOutput.fromPartial(object.stream) : void 0;
        message.segments = object.segments !== void 0 && object.segments !== null ? exports2.SegmentedFileOutput.fromPartial(object.segments) : void 0;
        message.preset = (_e = object.preset) !== null && _e !== void 0 ? _e : void 0;
        message.advanced = object.advanced !== void 0 && object.advanced !== null ? exports2.EncodingOptions.fromPartial(object.advanced) : void 0;
        message.fileOutputs = ((_f = object.fileOutputs) === null || _f === void 0 ? void 0 : _f.map((e) => exports2.EncodedFileOutput.fromPartial(e))) || [];
        message.streamOutputs = ((_g = object.streamOutputs) === null || _g === void 0 ? void 0 : _g.map((e) => exports2.StreamOutput.fromPartial(e))) || [];
        message.segmentOutputs = ((_h = object.segmentOutputs) === null || _h === void 0 ? void 0 : _h.map((e) => exports2.SegmentedFileOutput.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseTrackCompositeEgressRequest() {
      return {
        roomName: "",
        audioTrackId: "",
        videoTrackId: "",
        file: void 0,
        stream: void 0,
        segments: void 0,
        preset: void 0,
        advanced: void 0,
        fileOutputs: [],
        streamOutputs: [],
        segmentOutputs: []
      };
    }
    exports2.TrackCompositeEgressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(10).string(message.roomName);
        }
        if (message.audioTrackId !== void 0 && message.audioTrackId !== "") {
          writer.uint32(18).string(message.audioTrackId);
        }
        if (message.videoTrackId !== void 0 && message.videoTrackId !== "") {
          writer.uint32(26).string(message.videoTrackId);
        }
        if (message.file !== void 0) {
          exports2.EncodedFileOutput.encode(message.file, writer.uint32(34).fork()).ldelim();
        }
        if (message.stream !== void 0) {
          exports2.StreamOutput.encode(message.stream, writer.uint32(42).fork()).ldelim();
        }
        if (message.segments !== void 0) {
          exports2.SegmentedFileOutput.encode(message.segments, writer.uint32(66).fork()).ldelim();
        }
        if (message.preset !== void 0) {
          writer.uint32(48).int32(message.preset);
        }
        if (message.advanced !== void 0) {
          exports2.EncodingOptions.encode(message.advanced, writer.uint32(58).fork()).ldelim();
        }
        if (message.fileOutputs !== void 0 && message.fileOutputs.length !== 0) {
          for (const v of message.fileOutputs) {
            exports2.EncodedFileOutput.encode(v, writer.uint32(90).fork()).ldelim();
          }
        }
        if (message.streamOutputs !== void 0 && message.streamOutputs.length !== 0) {
          for (const v of message.streamOutputs) {
            exports2.StreamOutput.encode(v, writer.uint32(98).fork()).ldelim();
          }
        }
        if (message.segmentOutputs !== void 0 && message.segmentOutputs.length !== 0) {
          for (const v of message.segmentOutputs) {
            exports2.SegmentedFileOutput.encode(v, writer.uint32(106).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTrackCompositeEgressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.roomName = reader.string();
              break;
            case 2:
              message.audioTrackId = reader.string();
              break;
            case 3:
              message.videoTrackId = reader.string();
              break;
            case 4:
              message.file = exports2.EncodedFileOutput.decode(reader, reader.uint32());
              break;
            case 5:
              message.stream = exports2.StreamOutput.decode(reader, reader.uint32());
              break;
            case 8:
              message.segments = exports2.SegmentedFileOutput.decode(reader, reader.uint32());
              break;
            case 6:
              message.preset = reader.int32();
              break;
            case 7:
              message.advanced = exports2.EncodingOptions.decode(reader, reader.uint32());
              break;
            case 11:
              message.fileOutputs.push(exports2.EncodedFileOutput.decode(reader, reader.uint32()));
              break;
            case 12:
              message.streamOutputs.push(exports2.StreamOutput.decode(reader, reader.uint32()));
              break;
            case 13:
              message.segmentOutputs.push(exports2.SegmentedFileOutput.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          audioTrackId: isSet(object.audioTrackId) ? String(object.audioTrackId) : "",
          videoTrackId: isSet(object.videoTrackId) ? String(object.videoTrackId) : "",
          file: isSet(object.file) ? exports2.EncodedFileOutput.fromJSON(object.file) : void 0,
          stream: isSet(object.stream) ? exports2.StreamOutput.fromJSON(object.stream) : void 0,
          segments: isSet(object.segments) ? exports2.SegmentedFileOutput.fromJSON(object.segments) : void 0,
          preset: isSet(object.preset) ? encodingOptionsPresetFromJSON(object.preset) : void 0,
          advanced: isSet(object.advanced) ? exports2.EncodingOptions.fromJSON(object.advanced) : void 0,
          fileOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.fileOutputs) ? object.fileOutputs.map((e) => exports2.EncodedFileOutput.fromJSON(e)) : [],
          streamOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.streamOutputs) ? object.streamOutputs.map((e) => exports2.StreamOutput.fromJSON(e)) : [],
          segmentOutputs: Array.isArray(object === null || object === void 0 ? void 0 : object.segmentOutputs) ? object.segmentOutputs.map((e) => exports2.SegmentedFileOutput.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.audioTrackId !== void 0 && (obj.audioTrackId = message.audioTrackId);
        message.videoTrackId !== void 0 && (obj.videoTrackId = message.videoTrackId);
        message.file !== void 0 && (obj.file = message.file ? exports2.EncodedFileOutput.toJSON(message.file) : void 0);
        message.stream !== void 0 && (obj.stream = message.stream ? exports2.StreamOutput.toJSON(message.stream) : void 0);
        message.segments !== void 0 && (obj.segments = message.segments ? exports2.SegmentedFileOutput.toJSON(message.segments) : void 0);
        message.preset !== void 0 && (obj.preset = message.preset !== void 0 ? encodingOptionsPresetToJSON(message.preset) : void 0);
        message.advanced !== void 0 && (obj.advanced = message.advanced ? exports2.EncodingOptions.toJSON(message.advanced) : void 0);
        if (message.fileOutputs) {
          obj.fileOutputs = message.fileOutputs.map((e) => e ? exports2.EncodedFileOutput.toJSON(e) : void 0);
        } else {
          obj.fileOutputs = [];
        }
        if (message.streamOutputs) {
          obj.streamOutputs = message.streamOutputs.map((e) => e ? exports2.StreamOutput.toJSON(e) : void 0);
        } else {
          obj.streamOutputs = [];
        }
        if (message.segmentOutputs) {
          obj.segmentOutputs = message.segmentOutputs.map((e) => e ? exports2.SegmentedFileOutput.toJSON(e) : void 0);
        } else {
          obj.segmentOutputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseTrackCompositeEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.audioTrackId = (_b = object.audioTrackId) !== null && _b !== void 0 ? _b : "";
        message.videoTrackId = (_c = object.videoTrackId) !== null && _c !== void 0 ? _c : "";
        message.file = object.file !== void 0 && object.file !== null ? exports2.EncodedFileOutput.fromPartial(object.file) : void 0;
        message.stream = object.stream !== void 0 && object.stream !== null ? exports2.StreamOutput.fromPartial(object.stream) : void 0;
        message.segments = object.segments !== void 0 && object.segments !== null ? exports2.SegmentedFileOutput.fromPartial(object.segments) : void 0;
        message.preset = (_d = object.preset) !== null && _d !== void 0 ? _d : void 0;
        message.advanced = object.advanced !== void 0 && object.advanced !== null ? exports2.EncodingOptions.fromPartial(object.advanced) : void 0;
        message.fileOutputs = ((_e = object.fileOutputs) === null || _e === void 0 ? void 0 : _e.map((e) => exports2.EncodedFileOutput.fromPartial(e))) || [];
        message.streamOutputs = ((_f = object.streamOutputs) === null || _f === void 0 ? void 0 : _f.map((e) => exports2.StreamOutput.fromPartial(e))) || [];
        message.segmentOutputs = ((_g = object.segmentOutputs) === null || _g === void 0 ? void 0 : _g.map((e) => exports2.SegmentedFileOutput.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseTrackEgressRequest() {
      return { roomName: "", trackId: "", file: void 0, websocketUrl: void 0 };
    }
    exports2.TrackEgressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(10).string(message.roomName);
        }
        if (message.trackId !== void 0 && message.trackId !== "") {
          writer.uint32(18).string(message.trackId);
        }
        if (message.file !== void 0) {
          exports2.DirectFileOutput.encode(message.file, writer.uint32(26).fork()).ldelim();
        }
        if (message.websocketUrl !== void 0) {
          writer.uint32(34).string(message.websocketUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTrackEgressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.roomName = reader.string();
              break;
            case 2:
              message.trackId = reader.string();
              break;
            case 3:
              message.file = exports2.DirectFileOutput.decode(reader, reader.uint32());
              break;
            case 4:
              message.websocketUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          trackId: isSet(object.trackId) ? String(object.trackId) : "",
          file: isSet(object.file) ? exports2.DirectFileOutput.fromJSON(object.file) : void 0,
          websocketUrl: isSet(object.websocketUrl) ? String(object.websocketUrl) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.trackId !== void 0 && (obj.trackId = message.trackId);
        message.file !== void 0 && (obj.file = message.file ? exports2.DirectFileOutput.toJSON(message.file) : void 0);
        message.websocketUrl !== void 0 && (obj.websocketUrl = message.websocketUrl);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTrackEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.trackId = (_b = object.trackId) !== null && _b !== void 0 ? _b : "";
        message.file = object.file !== void 0 && object.file !== null ? exports2.DirectFileOutput.fromPartial(object.file) : void 0;
        message.websocketUrl = (_c = object.websocketUrl) !== null && _c !== void 0 ? _c : void 0;
        return message;
      }
    };
    function createBaseEncodedFileOutput() {
      return {
        fileType: 0,
        filepath: "",
        disableManifest: false,
        s3: void 0,
        gcp: void 0,
        azure: void 0,
        aliOSS: void 0
      };
    }
    exports2.EncodedFileOutput = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fileType !== void 0 && message.fileType !== 0) {
          writer.uint32(8).int32(message.fileType);
        }
        if (message.filepath !== void 0 && message.filepath !== "") {
          writer.uint32(18).string(message.filepath);
        }
        if (message.disableManifest === true) {
          writer.uint32(48).bool(message.disableManifest);
        }
        if (message.s3 !== void 0) {
          exports2.S3Upload.encode(message.s3, writer.uint32(26).fork()).ldelim();
        }
        if (message.gcp !== void 0) {
          exports2.GCPUpload.encode(message.gcp, writer.uint32(34).fork()).ldelim();
        }
        if (message.azure !== void 0) {
          exports2.AzureBlobUpload.encode(message.azure, writer.uint32(42).fork()).ldelim();
        }
        if (message.aliOSS !== void 0) {
          exports2.AliOSSUpload.encode(message.aliOSS, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEncodedFileOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fileType = reader.int32();
              break;
            case 2:
              message.filepath = reader.string();
              break;
            case 6:
              message.disableManifest = reader.bool();
              break;
            case 3:
              message.s3 = exports2.S3Upload.decode(reader, reader.uint32());
              break;
            case 4:
              message.gcp = exports2.GCPUpload.decode(reader, reader.uint32());
              break;
            case 5:
              message.azure = exports2.AzureBlobUpload.decode(reader, reader.uint32());
              break;
            case 7:
              message.aliOSS = exports2.AliOSSUpload.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          fileType: isSet(object.fileType) ? encodedFileTypeFromJSON(object.fileType) : 0,
          filepath: isSet(object.filepath) ? String(object.filepath) : "",
          disableManifest: isSet(object.disableManifest) ? Boolean(object.disableManifest) : false,
          s3: isSet(object.s3) ? exports2.S3Upload.fromJSON(object.s3) : void 0,
          gcp: isSet(object.gcp) ? exports2.GCPUpload.fromJSON(object.gcp) : void 0,
          azure: isSet(object.azure) ? exports2.AzureBlobUpload.fromJSON(object.azure) : void 0,
          aliOSS: isSet(object.aliOSS) ? exports2.AliOSSUpload.fromJSON(object.aliOSS) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.fileType !== void 0 && (obj.fileType = encodedFileTypeToJSON(message.fileType));
        message.filepath !== void 0 && (obj.filepath = message.filepath);
        message.disableManifest !== void 0 && (obj.disableManifest = message.disableManifest);
        message.s3 !== void 0 && (obj.s3 = message.s3 ? exports2.S3Upload.toJSON(message.s3) : void 0);
        message.gcp !== void 0 && (obj.gcp = message.gcp ? exports2.GCPUpload.toJSON(message.gcp) : void 0);
        message.azure !== void 0 && (obj.azure = message.azure ? exports2.AzureBlobUpload.toJSON(message.azure) : void 0);
        message.aliOSS !== void 0 && (obj.aliOSS = message.aliOSS ? exports2.AliOSSUpload.toJSON(message.aliOSS) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseEncodedFileOutput();
        message.fileType = (_a = object.fileType) !== null && _a !== void 0 ? _a : 0;
        message.filepath = (_b = object.filepath) !== null && _b !== void 0 ? _b : "";
        message.disableManifest = (_c = object.disableManifest) !== null && _c !== void 0 ? _c : false;
        message.s3 = object.s3 !== void 0 && object.s3 !== null ? exports2.S3Upload.fromPartial(object.s3) : void 0;
        message.gcp = object.gcp !== void 0 && object.gcp !== null ? exports2.GCPUpload.fromPartial(object.gcp) : void 0;
        message.azure = object.azure !== void 0 && object.azure !== null ? exports2.AzureBlobUpload.fromPartial(object.azure) : void 0;
        message.aliOSS = object.aliOSS !== void 0 && object.aliOSS !== null ? exports2.AliOSSUpload.fromPartial(object.aliOSS) : void 0;
        return message;
      }
    };
    function createBaseSegmentedFileOutput() {
      return {
        protocol: 0,
        filenamePrefix: "",
        playlistName: "",
        segmentDuration: 0,
        filenameSuffix: 0,
        disableManifest: false,
        s3: void 0,
        gcp: void 0,
        azure: void 0,
        aliOSS: void 0
      };
    }
    exports2.SegmentedFileOutput = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.protocol !== void 0 && message.protocol !== 0) {
          writer.uint32(8).int32(message.protocol);
        }
        if (message.filenamePrefix !== void 0 && message.filenamePrefix !== "") {
          writer.uint32(18).string(message.filenamePrefix);
        }
        if (message.playlistName !== void 0 && message.playlistName !== "") {
          writer.uint32(26).string(message.playlistName);
        }
        if (message.segmentDuration !== void 0 && message.segmentDuration !== 0) {
          writer.uint32(32).uint32(message.segmentDuration);
        }
        if (message.filenameSuffix !== void 0 && message.filenameSuffix !== 0) {
          writer.uint32(80).int32(message.filenameSuffix);
        }
        if (message.disableManifest === true) {
          writer.uint32(64).bool(message.disableManifest);
        }
        if (message.s3 !== void 0) {
          exports2.S3Upload.encode(message.s3, writer.uint32(42).fork()).ldelim();
        }
        if (message.gcp !== void 0) {
          exports2.GCPUpload.encode(message.gcp, writer.uint32(50).fork()).ldelim();
        }
        if (message.azure !== void 0) {
          exports2.AzureBlobUpload.encode(message.azure, writer.uint32(58).fork()).ldelim();
        }
        if (message.aliOSS !== void 0) {
          exports2.AliOSSUpload.encode(message.aliOSS, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSegmentedFileOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.int32();
              break;
            case 2:
              message.filenamePrefix = reader.string();
              break;
            case 3:
              message.playlistName = reader.string();
              break;
            case 4:
              message.segmentDuration = reader.uint32();
              break;
            case 10:
              message.filenameSuffix = reader.int32();
              break;
            case 8:
              message.disableManifest = reader.bool();
              break;
            case 5:
              message.s3 = exports2.S3Upload.decode(reader, reader.uint32());
              break;
            case 6:
              message.gcp = exports2.GCPUpload.decode(reader, reader.uint32());
              break;
            case 7:
              message.azure = exports2.AzureBlobUpload.decode(reader, reader.uint32());
              break;
            case 9:
              message.aliOSS = exports2.AliOSSUpload.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          protocol: isSet(object.protocol) ? segmentedFileProtocolFromJSON(object.protocol) : 0,
          filenamePrefix: isSet(object.filenamePrefix) ? String(object.filenamePrefix) : "",
          playlistName: isSet(object.playlistName) ? String(object.playlistName) : "",
          segmentDuration: isSet(object.segmentDuration) ? Number(object.segmentDuration) : 0,
          filenameSuffix: isSet(object.filenameSuffix) ? segmentedFileSuffixFromJSON(object.filenameSuffix) : 0,
          disableManifest: isSet(object.disableManifest) ? Boolean(object.disableManifest) : false,
          s3: isSet(object.s3) ? exports2.S3Upload.fromJSON(object.s3) : void 0,
          gcp: isSet(object.gcp) ? exports2.GCPUpload.fromJSON(object.gcp) : void 0,
          azure: isSet(object.azure) ? exports2.AzureBlobUpload.fromJSON(object.azure) : void 0,
          aliOSS: isSet(object.aliOSS) ? exports2.AliOSSUpload.fromJSON(object.aliOSS) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = segmentedFileProtocolToJSON(message.protocol));
        message.filenamePrefix !== void 0 && (obj.filenamePrefix = message.filenamePrefix);
        message.playlistName !== void 0 && (obj.playlistName = message.playlistName);
        message.segmentDuration !== void 0 && (obj.segmentDuration = Math.round(message.segmentDuration));
        message.filenameSuffix !== void 0 && (obj.filenameSuffix = segmentedFileSuffixToJSON(message.filenameSuffix));
        message.disableManifest !== void 0 && (obj.disableManifest = message.disableManifest);
        message.s3 !== void 0 && (obj.s3 = message.s3 ? exports2.S3Upload.toJSON(message.s3) : void 0);
        message.gcp !== void 0 && (obj.gcp = message.gcp ? exports2.GCPUpload.toJSON(message.gcp) : void 0);
        message.azure !== void 0 && (obj.azure = message.azure ? exports2.AzureBlobUpload.toJSON(message.azure) : void 0);
        message.aliOSS !== void 0 && (obj.aliOSS = message.aliOSS ? exports2.AliOSSUpload.toJSON(message.aliOSS) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseSegmentedFileOutput();
        message.protocol = (_a = object.protocol) !== null && _a !== void 0 ? _a : 0;
        message.filenamePrefix = (_b = object.filenamePrefix) !== null && _b !== void 0 ? _b : "";
        message.playlistName = (_c = object.playlistName) !== null && _c !== void 0 ? _c : "";
        message.segmentDuration = (_d = object.segmentDuration) !== null && _d !== void 0 ? _d : 0;
        message.filenameSuffix = (_e = object.filenameSuffix) !== null && _e !== void 0 ? _e : 0;
        message.disableManifest = (_f = object.disableManifest) !== null && _f !== void 0 ? _f : false;
        message.s3 = object.s3 !== void 0 && object.s3 !== null ? exports2.S3Upload.fromPartial(object.s3) : void 0;
        message.gcp = object.gcp !== void 0 && object.gcp !== null ? exports2.GCPUpload.fromPartial(object.gcp) : void 0;
        message.azure = object.azure !== void 0 && object.azure !== null ? exports2.AzureBlobUpload.fromPartial(object.azure) : void 0;
        message.aliOSS = object.aliOSS !== void 0 && object.aliOSS !== null ? exports2.AliOSSUpload.fromPartial(object.aliOSS) : void 0;
        return message;
      }
    };
    function createBaseDirectFileOutput() {
      return { filepath: "", disableManifest: false, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };
    }
    exports2.DirectFileOutput = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.filepath !== void 0 && message.filepath !== "") {
          writer.uint32(10).string(message.filepath);
        }
        if (message.disableManifest === true) {
          writer.uint32(40).bool(message.disableManifest);
        }
        if (message.s3 !== void 0) {
          exports2.S3Upload.encode(message.s3, writer.uint32(18).fork()).ldelim();
        }
        if (message.gcp !== void 0) {
          exports2.GCPUpload.encode(message.gcp, writer.uint32(26).fork()).ldelim();
        }
        if (message.azure !== void 0) {
          exports2.AzureBlobUpload.encode(message.azure, writer.uint32(34).fork()).ldelim();
        }
        if (message.aliOSS !== void 0) {
          exports2.AliOSSUpload.encode(message.aliOSS, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDirectFileOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.filepath = reader.string();
              break;
            case 5:
              message.disableManifest = reader.bool();
              break;
            case 2:
              message.s3 = exports2.S3Upload.decode(reader, reader.uint32());
              break;
            case 3:
              message.gcp = exports2.GCPUpload.decode(reader, reader.uint32());
              break;
            case 4:
              message.azure = exports2.AzureBlobUpload.decode(reader, reader.uint32());
              break;
            case 6:
              message.aliOSS = exports2.AliOSSUpload.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          filepath: isSet(object.filepath) ? String(object.filepath) : "",
          disableManifest: isSet(object.disableManifest) ? Boolean(object.disableManifest) : false,
          s3: isSet(object.s3) ? exports2.S3Upload.fromJSON(object.s3) : void 0,
          gcp: isSet(object.gcp) ? exports2.GCPUpload.fromJSON(object.gcp) : void 0,
          azure: isSet(object.azure) ? exports2.AzureBlobUpload.fromJSON(object.azure) : void 0,
          aliOSS: isSet(object.aliOSS) ? exports2.AliOSSUpload.fromJSON(object.aliOSS) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.filepath !== void 0 && (obj.filepath = message.filepath);
        message.disableManifest !== void 0 && (obj.disableManifest = message.disableManifest);
        message.s3 !== void 0 && (obj.s3 = message.s3 ? exports2.S3Upload.toJSON(message.s3) : void 0);
        message.gcp !== void 0 && (obj.gcp = message.gcp ? exports2.GCPUpload.toJSON(message.gcp) : void 0);
        message.azure !== void 0 && (obj.azure = message.azure ? exports2.AzureBlobUpload.toJSON(message.azure) : void 0);
        message.aliOSS !== void 0 && (obj.aliOSS = message.aliOSS ? exports2.AliOSSUpload.toJSON(message.aliOSS) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDirectFileOutput();
        message.filepath = (_a = object.filepath) !== null && _a !== void 0 ? _a : "";
        message.disableManifest = (_b = object.disableManifest) !== null && _b !== void 0 ? _b : false;
        message.s3 = object.s3 !== void 0 && object.s3 !== null ? exports2.S3Upload.fromPartial(object.s3) : void 0;
        message.gcp = object.gcp !== void 0 && object.gcp !== null ? exports2.GCPUpload.fromPartial(object.gcp) : void 0;
        message.azure = object.azure !== void 0 && object.azure !== null ? exports2.AzureBlobUpload.fromPartial(object.azure) : void 0;
        message.aliOSS = object.aliOSS !== void 0 && object.aliOSS !== null ? exports2.AliOSSUpload.fromPartial(object.aliOSS) : void 0;
        return message;
      }
    };
    function createBaseS3Upload() {
      return {
        accessKey: "",
        secret: "",
        region: "",
        endpoint: "",
        bucket: "",
        forcePathStyle: false,
        metadata: {},
        tagging: ""
      };
    }
    exports2.S3Upload = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.accessKey !== void 0 && message.accessKey !== "") {
          writer.uint32(10).string(message.accessKey);
        }
        if (message.secret !== void 0 && message.secret !== "") {
          writer.uint32(18).string(message.secret);
        }
        if (message.region !== void 0 && message.region !== "") {
          writer.uint32(26).string(message.region);
        }
        if (message.endpoint !== void 0 && message.endpoint !== "") {
          writer.uint32(34).string(message.endpoint);
        }
        if (message.bucket !== void 0 && message.bucket !== "") {
          writer.uint32(42).string(message.bucket);
        }
        if (message.forcePathStyle === true) {
          writer.uint32(48).bool(message.forcePathStyle);
        }
        Object.entries(message.metadata || {}).forEach(([key, value]) => {
          exports2.S3Upload_MetadataEntry.encode({ key, value }, writer.uint32(58).fork()).ldelim();
        });
        if (message.tagging !== void 0 && message.tagging !== "") {
          writer.uint32(66).string(message.tagging);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseS3Upload();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accessKey = reader.string();
              break;
            case 2:
              message.secret = reader.string();
              break;
            case 3:
              message.region = reader.string();
              break;
            case 4:
              message.endpoint = reader.string();
              break;
            case 5:
              message.bucket = reader.string();
              break;
            case 6:
              message.forcePathStyle = reader.bool();
              break;
            case 7:
              const entry7 = exports2.S3Upload_MetadataEntry.decode(reader, reader.uint32());
              if (entry7.value !== void 0) {
                message.metadata[entry7.key] = entry7.value;
              }
              break;
            case 8:
              message.tagging = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          accessKey: isSet(object.accessKey) ? String(object.accessKey) : "",
          secret: isSet(object.secret) ? String(object.secret) : "",
          region: isSet(object.region) ? String(object.region) : "",
          endpoint: isSet(object.endpoint) ? String(object.endpoint) : "",
          bucket: isSet(object.bucket) ? String(object.bucket) : "",
          forcePathStyle: isSet(object.forcePathStyle) ? Boolean(object.forcePathStyle) : false,
          metadata: isObject(object.metadata) ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
            acc[key] = String(value);
            return acc;
          }, {}) : {},
          tagging: isSet(object.tagging) ? String(object.tagging) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.accessKey !== void 0 && (obj.accessKey = message.accessKey);
        message.secret !== void 0 && (obj.secret = message.secret);
        message.region !== void 0 && (obj.region = message.region);
        message.endpoint !== void 0 && (obj.endpoint = message.endpoint);
        message.bucket !== void 0 && (obj.bucket = message.bucket);
        message.forcePathStyle !== void 0 && (obj.forcePathStyle = message.forcePathStyle);
        obj.metadata = {};
        if (message.metadata) {
          Object.entries(message.metadata).forEach(([k, v]) => {
            obj.metadata[k] = v;
          });
        }
        message.tagging !== void 0 && (obj.tagging = message.tagging);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseS3Upload();
        message.accessKey = (_a = object.accessKey) !== null && _a !== void 0 ? _a : "";
        message.secret = (_b = object.secret) !== null && _b !== void 0 ? _b : "";
        message.region = (_c = object.region) !== null && _c !== void 0 ? _c : "";
        message.endpoint = (_d = object.endpoint) !== null && _d !== void 0 ? _d : "";
        message.bucket = (_e = object.bucket) !== null && _e !== void 0 ? _e : "";
        message.forcePathStyle = (_f = object.forcePathStyle) !== null && _f !== void 0 ? _f : false;
        message.metadata = Object.entries((_g = object.metadata) !== null && _g !== void 0 ? _g : {}).reduce((acc, [key, value]) => {
          if (value !== void 0) {
            acc[key] = String(value);
          }
          return acc;
        }, {});
        message.tagging = (_h = object.tagging) !== null && _h !== void 0 ? _h : "";
        return message;
      }
    };
    function createBaseS3Upload_MetadataEntry() {
      return { key: "", value: "" };
    }
    exports2.S3Upload_MetadataEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseS3Upload_MetadataEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseS3Upload_MetadataEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseGCPUpload() {
      return { credentials: "", bucket: "" };
    }
    exports2.GCPUpload = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.credentials !== void 0 && message.credentials !== "") {
          writer.uint32(10).string(message.credentials);
        }
        if (message.bucket !== void 0 && message.bucket !== "") {
          writer.uint32(18).string(message.bucket);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGCPUpload();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.credentials = reader.string();
              break;
            case 2:
              message.bucket = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          credentials: isSet(object.credentials) ? String(object.credentials) : "",
          bucket: isSet(object.bucket) ? String(object.bucket) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.credentials !== void 0 && (obj.credentials = message.credentials);
        message.bucket !== void 0 && (obj.bucket = message.bucket);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseGCPUpload();
        message.credentials = (_a = object.credentials) !== null && _a !== void 0 ? _a : "";
        message.bucket = (_b = object.bucket) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseAzureBlobUpload() {
      return { accountName: "", accountKey: "", containerName: "" };
    }
    exports2.AzureBlobUpload = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.accountName !== void 0 && message.accountName !== "") {
          writer.uint32(10).string(message.accountName);
        }
        if (message.accountKey !== void 0 && message.accountKey !== "") {
          writer.uint32(18).string(message.accountKey);
        }
        if (message.containerName !== void 0 && message.containerName !== "") {
          writer.uint32(26).string(message.containerName);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAzureBlobUpload();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accountName = reader.string();
              break;
            case 2:
              message.accountKey = reader.string();
              break;
            case 3:
              message.containerName = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          accountName: isSet(object.accountName) ? String(object.accountName) : "",
          accountKey: isSet(object.accountKey) ? String(object.accountKey) : "",
          containerName: isSet(object.containerName) ? String(object.containerName) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.accountName !== void 0 && (obj.accountName = message.accountName);
        message.accountKey !== void 0 && (obj.accountKey = message.accountKey);
        message.containerName !== void 0 && (obj.containerName = message.containerName);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAzureBlobUpload();
        message.accountName = (_a = object.accountName) !== null && _a !== void 0 ? _a : "";
        message.accountKey = (_b = object.accountKey) !== null && _b !== void 0 ? _b : "";
        message.containerName = (_c = object.containerName) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseAliOSSUpload() {
      return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
    }
    exports2.AliOSSUpload = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.accessKey !== void 0 && message.accessKey !== "") {
          writer.uint32(10).string(message.accessKey);
        }
        if (message.secret !== void 0 && message.secret !== "") {
          writer.uint32(18).string(message.secret);
        }
        if (message.region !== void 0 && message.region !== "") {
          writer.uint32(26).string(message.region);
        }
        if (message.endpoint !== void 0 && message.endpoint !== "") {
          writer.uint32(34).string(message.endpoint);
        }
        if (message.bucket !== void 0 && message.bucket !== "") {
          writer.uint32(42).string(message.bucket);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAliOSSUpload();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accessKey = reader.string();
              break;
            case 2:
              message.secret = reader.string();
              break;
            case 3:
              message.region = reader.string();
              break;
            case 4:
              message.endpoint = reader.string();
              break;
            case 5:
              message.bucket = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          accessKey: isSet(object.accessKey) ? String(object.accessKey) : "",
          secret: isSet(object.secret) ? String(object.secret) : "",
          region: isSet(object.region) ? String(object.region) : "",
          endpoint: isSet(object.endpoint) ? String(object.endpoint) : "",
          bucket: isSet(object.bucket) ? String(object.bucket) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.accessKey !== void 0 && (obj.accessKey = message.accessKey);
        message.secret !== void 0 && (obj.secret = message.secret);
        message.region !== void 0 && (obj.region = message.region);
        message.endpoint !== void 0 && (obj.endpoint = message.endpoint);
        message.bucket !== void 0 && (obj.bucket = message.bucket);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseAliOSSUpload();
        message.accessKey = (_a = object.accessKey) !== null && _a !== void 0 ? _a : "";
        message.secret = (_b = object.secret) !== null && _b !== void 0 ? _b : "";
        message.region = (_c = object.region) !== null && _c !== void 0 ? _c : "";
        message.endpoint = (_d = object.endpoint) !== null && _d !== void 0 ? _d : "";
        message.bucket = (_e = object.bucket) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    function createBaseStreamOutput() {
      return { protocol: 0, urls: [] };
    }
    exports2.StreamOutput = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.protocol !== void 0 && message.protocol !== 0) {
          writer.uint32(8).int32(message.protocol);
        }
        if (message.urls !== void 0 && message.urls.length !== 0) {
          for (const v of message.urls) {
            writer.uint32(18).string(v);
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStreamOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.int32();
              break;
            case 2:
              message.urls.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          protocol: isSet(object.protocol) ? streamProtocolFromJSON(object.protocol) : 0,
          urls: Array.isArray(object === null || object === void 0 ? void 0 : object.urls) ? object.urls.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = streamProtocolToJSON(message.protocol));
        if (message.urls) {
          obj.urls = message.urls.map((e) => e);
        } else {
          obj.urls = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseStreamOutput();
        message.protocol = (_a = object.protocol) !== null && _a !== void 0 ? _a : 0;
        message.urls = ((_b = object.urls) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseEncodingOptions() {
      return {
        width: 0,
        height: 0,
        depth: 0,
        framerate: 0,
        audioCodec: 0,
        audioBitrate: 0,
        audioFrequency: 0,
        videoCodec: 0,
        videoBitrate: 0,
        keyFrameInterval: 0
      };
    }
    exports2.EncodingOptions = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.width !== void 0 && message.width !== 0) {
          writer.uint32(8).int32(message.width);
        }
        if (message.height !== void 0 && message.height !== 0) {
          writer.uint32(16).int32(message.height);
        }
        if (message.depth !== void 0 && message.depth !== 0) {
          writer.uint32(24).int32(message.depth);
        }
        if (message.framerate !== void 0 && message.framerate !== 0) {
          writer.uint32(32).int32(message.framerate);
        }
        if (message.audioCodec !== void 0 && message.audioCodec !== 0) {
          writer.uint32(40).int32(message.audioCodec);
        }
        if (message.audioBitrate !== void 0 && message.audioBitrate !== 0) {
          writer.uint32(48).int32(message.audioBitrate);
        }
        if (message.audioFrequency !== void 0 && message.audioFrequency !== 0) {
          writer.uint32(56).int32(message.audioFrequency);
        }
        if (message.videoCodec !== void 0 && message.videoCodec !== 0) {
          writer.uint32(64).int32(message.videoCodec);
        }
        if (message.videoBitrate !== void 0 && message.videoBitrate !== 0) {
          writer.uint32(72).int32(message.videoBitrate);
        }
        if (message.keyFrameInterval !== void 0 && message.keyFrameInterval !== 0) {
          writer.uint32(81).double(message.keyFrameInterval);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEncodingOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.width = reader.int32();
              break;
            case 2:
              message.height = reader.int32();
              break;
            case 3:
              message.depth = reader.int32();
              break;
            case 4:
              message.framerate = reader.int32();
              break;
            case 5:
              message.audioCodec = reader.int32();
              break;
            case 6:
              message.audioBitrate = reader.int32();
              break;
            case 7:
              message.audioFrequency = reader.int32();
              break;
            case 8:
              message.videoCodec = reader.int32();
              break;
            case 9:
              message.videoBitrate = reader.int32();
              break;
            case 10:
              message.keyFrameInterval = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          width: isSet(object.width) ? Number(object.width) : 0,
          height: isSet(object.height) ? Number(object.height) : 0,
          depth: isSet(object.depth) ? Number(object.depth) : 0,
          framerate: isSet(object.framerate) ? Number(object.framerate) : 0,
          audioCodec: isSet(object.audioCodec) ? livekit_models_1.audioCodecFromJSON(object.audioCodec) : 0,
          audioBitrate: isSet(object.audioBitrate) ? Number(object.audioBitrate) : 0,
          audioFrequency: isSet(object.audioFrequency) ? Number(object.audioFrequency) : 0,
          videoCodec: isSet(object.videoCodec) ? livekit_models_1.videoCodecFromJSON(object.videoCodec) : 0,
          videoBitrate: isSet(object.videoBitrate) ? Number(object.videoBitrate) : 0,
          keyFrameInterval: isSet(object.keyFrameInterval) ? Number(object.keyFrameInterval) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.width !== void 0 && (obj.width = Math.round(message.width));
        message.height !== void 0 && (obj.height = Math.round(message.height));
        message.depth !== void 0 && (obj.depth = Math.round(message.depth));
        message.framerate !== void 0 && (obj.framerate = Math.round(message.framerate));
        message.audioCodec !== void 0 && (obj.audioCodec = livekit_models_1.audioCodecToJSON(message.audioCodec));
        message.audioBitrate !== void 0 && (obj.audioBitrate = Math.round(message.audioBitrate));
        message.audioFrequency !== void 0 && (obj.audioFrequency = Math.round(message.audioFrequency));
        message.videoCodec !== void 0 && (obj.videoCodec = livekit_models_1.videoCodecToJSON(message.videoCodec));
        message.videoBitrate !== void 0 && (obj.videoBitrate = Math.round(message.videoBitrate));
        message.keyFrameInterval !== void 0 && (obj.keyFrameInterval = message.keyFrameInterval);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseEncodingOptions();
        message.width = (_a = object.width) !== null && _a !== void 0 ? _a : 0;
        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : 0;
        message.depth = (_c = object.depth) !== null && _c !== void 0 ? _c : 0;
        message.framerate = (_d = object.framerate) !== null && _d !== void 0 ? _d : 0;
        message.audioCodec = (_e = object.audioCodec) !== null && _e !== void 0 ? _e : 0;
        message.audioBitrate = (_f = object.audioBitrate) !== null && _f !== void 0 ? _f : 0;
        message.audioFrequency = (_g = object.audioFrequency) !== null && _g !== void 0 ? _g : 0;
        message.videoCodec = (_h = object.videoCodec) !== null && _h !== void 0 ? _h : 0;
        message.videoBitrate = (_j = object.videoBitrate) !== null && _j !== void 0 ? _j : 0;
        message.keyFrameInterval = (_k = object.keyFrameInterval) !== null && _k !== void 0 ? _k : 0;
        return message;
      }
    };
    function createBaseUpdateLayoutRequest() {
      return { egressId: "", layout: "" };
    }
    exports2.UpdateLayoutRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.egressId !== void 0 && message.egressId !== "") {
          writer.uint32(10).string(message.egressId);
        }
        if (message.layout !== void 0 && message.layout !== "") {
          writer.uint32(18).string(message.layout);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateLayoutRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.egressId = reader.string();
              break;
            case 2:
              message.layout = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          egressId: isSet(object.egressId) ? String(object.egressId) : "",
          layout: isSet(object.layout) ? String(object.layout) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.egressId !== void 0 && (obj.egressId = message.egressId);
        message.layout !== void 0 && (obj.layout = message.layout);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseUpdateLayoutRequest();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        message.layout = (_b = object.layout) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseUpdateStreamRequest() {
      return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
    }
    exports2.UpdateStreamRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.egressId !== void 0 && message.egressId !== "") {
          writer.uint32(10).string(message.egressId);
        }
        if (message.addOutputUrls !== void 0 && message.addOutputUrls.length !== 0) {
          for (const v of message.addOutputUrls) {
            writer.uint32(18).string(v);
          }
        }
        if (message.removeOutputUrls !== void 0 && message.removeOutputUrls.length !== 0) {
          for (const v of message.removeOutputUrls) {
            writer.uint32(26).string(v);
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateStreamRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.egressId = reader.string();
              break;
            case 2:
              message.addOutputUrls.push(reader.string());
              break;
            case 3:
              message.removeOutputUrls.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          egressId: isSet(object.egressId) ? String(object.egressId) : "",
          addOutputUrls: Array.isArray(object === null || object === void 0 ? void 0 : object.addOutputUrls) ? object.addOutputUrls.map((e) => String(e)) : [],
          removeOutputUrls: Array.isArray(object === null || object === void 0 ? void 0 : object.removeOutputUrls) ? object.removeOutputUrls.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.egressId !== void 0 && (obj.egressId = message.egressId);
        if (message.addOutputUrls) {
          obj.addOutputUrls = message.addOutputUrls.map((e) => e);
        } else {
          obj.addOutputUrls = [];
        }
        if (message.removeOutputUrls) {
          obj.removeOutputUrls = message.removeOutputUrls.map((e) => e);
        } else {
          obj.removeOutputUrls = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUpdateStreamRequest();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        message.addOutputUrls = ((_b = object.addOutputUrls) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.removeOutputUrls = ((_c = object.removeOutputUrls) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseListEgressRequest() {
      return { roomName: "", egressId: "", active: false };
    }
    exports2.ListEgressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(10).string(message.roomName);
        }
        if (message.egressId !== void 0 && message.egressId !== "") {
          writer.uint32(18).string(message.egressId);
        }
        if (message.active === true) {
          writer.uint32(24).bool(message.active);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListEgressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.roomName = reader.string();
              break;
            case 2:
              message.egressId = reader.string();
              break;
            case 3:
              message.active = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          egressId: isSet(object.egressId) ? String(object.egressId) : "",
          active: isSet(object.active) ? Boolean(object.active) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.egressId !== void 0 && (obj.egressId = message.egressId);
        message.active !== void 0 && (obj.active = message.active);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseListEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.egressId = (_b = object.egressId) !== null && _b !== void 0 ? _b : "";
        message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    function createBaseListEgressResponse() {
      return { items: [] };
    }
    exports2.ListEgressResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.items !== void 0 && message.items.length !== 0) {
          for (const v of message.items) {
            exports2.EgressInfo.encode(v, writer.uint32(10).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListEgressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.items.push(exports2.EgressInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { items: Array.isArray(object === null || object === void 0 ? void 0 : object.items) ? object.items.map((e) => exports2.EgressInfo.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.items) {
          obj.items = message.items.map((e) => e ? exports2.EgressInfo.toJSON(e) : void 0);
        } else {
          obj.items = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseListEgressResponse();
        message.items = ((_a = object.items) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.EgressInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseStopEgressRequest() {
      return { egressId: "" };
    }
    exports2.StopEgressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.egressId !== void 0 && message.egressId !== "") {
          writer.uint32(10).string(message.egressId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStopEgressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.egressId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { egressId: isSet(object.egressId) ? String(object.egressId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.egressId !== void 0 && (obj.egressId = message.egressId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseStopEgressRequest();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseEgressInfo() {
      return {
        egressId: "",
        roomId: "",
        roomName: "",
        status: 0,
        startedAt: 0,
        endedAt: 0,
        updatedAt: 0,
        error: "",
        roomComposite: void 0,
        trackComposite: void 0,
        track: void 0,
        web: void 0,
        stream: void 0,
        file: void 0,
        segments: void 0,
        streamResults: [],
        fileResults: [],
        segmentResults: []
      };
    }
    exports2.EgressInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.egressId !== void 0 && message.egressId !== "") {
          writer.uint32(10).string(message.egressId);
        }
        if (message.roomId !== void 0 && message.roomId !== "") {
          writer.uint32(18).string(message.roomId);
        }
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(106).string(message.roomName);
        }
        if (message.status !== void 0 && message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.startedAt !== void 0 && message.startedAt !== 0) {
          writer.uint32(80).int64(message.startedAt);
        }
        if (message.endedAt !== void 0 && message.endedAt !== 0) {
          writer.uint32(88).int64(message.endedAt);
        }
        if (message.updatedAt !== void 0 && message.updatedAt !== 0) {
          writer.uint32(144).int64(message.updatedAt);
        }
        if (message.error !== void 0 && message.error !== "") {
          writer.uint32(74).string(message.error);
        }
        if (message.roomComposite !== void 0) {
          exports2.RoomCompositeEgressRequest.encode(message.roomComposite, writer.uint32(34).fork()).ldelim();
        }
        if (message.trackComposite !== void 0) {
          exports2.TrackCompositeEgressRequest.encode(message.trackComposite, writer.uint32(42).fork()).ldelim();
        }
        if (message.track !== void 0) {
          exports2.TrackEgressRequest.encode(message.track, writer.uint32(50).fork()).ldelim();
        }
        if (message.web !== void 0) {
          exports2.WebEgressRequest.encode(message.web, writer.uint32(114).fork()).ldelim();
        }
        if (message.stream !== void 0) {
          exports2.StreamInfoList.encode(message.stream, writer.uint32(58).fork()).ldelim();
        }
        if (message.file !== void 0) {
          exports2.FileInfo.encode(message.file, writer.uint32(66).fork()).ldelim();
        }
        if (message.segments !== void 0) {
          exports2.SegmentsInfo.encode(message.segments, writer.uint32(98).fork()).ldelim();
        }
        if (message.streamResults !== void 0 && message.streamResults.length !== 0) {
          for (const v of message.streamResults) {
            exports2.StreamInfo.encode(v, writer.uint32(122).fork()).ldelim();
          }
        }
        if (message.fileResults !== void 0 && message.fileResults.length !== 0) {
          for (const v of message.fileResults) {
            exports2.FileInfo.encode(v, writer.uint32(130).fork()).ldelim();
          }
        }
        if (message.segmentResults !== void 0 && message.segmentResults.length !== 0) {
          for (const v of message.segmentResults) {
            exports2.SegmentsInfo.encode(v, writer.uint32(138).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEgressInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.egressId = reader.string();
              break;
            case 2:
              message.roomId = reader.string();
              break;
            case 13:
              message.roomName = reader.string();
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 10:
              message.startedAt = longToNumber(reader.int64());
              break;
            case 11:
              message.endedAt = longToNumber(reader.int64());
              break;
            case 18:
              message.updatedAt = longToNumber(reader.int64());
              break;
            case 9:
              message.error = reader.string();
              break;
            case 4:
              message.roomComposite = exports2.RoomCompositeEgressRequest.decode(reader, reader.uint32());
              break;
            case 5:
              message.trackComposite = exports2.TrackCompositeEgressRequest.decode(reader, reader.uint32());
              break;
            case 6:
              message.track = exports2.TrackEgressRequest.decode(reader, reader.uint32());
              break;
            case 14:
              message.web = exports2.WebEgressRequest.decode(reader, reader.uint32());
              break;
            case 7:
              message.stream = exports2.StreamInfoList.decode(reader, reader.uint32());
              break;
            case 8:
              message.file = exports2.FileInfo.decode(reader, reader.uint32());
              break;
            case 12:
              message.segments = exports2.SegmentsInfo.decode(reader, reader.uint32());
              break;
            case 15:
              message.streamResults.push(exports2.StreamInfo.decode(reader, reader.uint32()));
              break;
            case 16:
              message.fileResults.push(exports2.FileInfo.decode(reader, reader.uint32()));
              break;
            case 17:
              message.segmentResults.push(exports2.SegmentsInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          egressId: isSet(object.egressId) ? String(object.egressId) : "",
          roomId: isSet(object.roomId) ? String(object.roomId) : "",
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          status: isSet(object.status) ? egressStatusFromJSON(object.status) : 0,
          startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
          endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0,
          updatedAt: isSet(object.updatedAt) ? Number(object.updatedAt) : 0,
          error: isSet(object.error) ? String(object.error) : "",
          roomComposite: isSet(object.roomComposite) ? exports2.RoomCompositeEgressRequest.fromJSON(object.roomComposite) : void 0,
          trackComposite: isSet(object.trackComposite) ? exports2.TrackCompositeEgressRequest.fromJSON(object.trackComposite) : void 0,
          track: isSet(object.track) ? exports2.TrackEgressRequest.fromJSON(object.track) : void 0,
          web: isSet(object.web) ? exports2.WebEgressRequest.fromJSON(object.web) : void 0,
          stream: isSet(object.stream) ? exports2.StreamInfoList.fromJSON(object.stream) : void 0,
          file: isSet(object.file) ? exports2.FileInfo.fromJSON(object.file) : void 0,
          segments: isSet(object.segments) ? exports2.SegmentsInfo.fromJSON(object.segments) : void 0,
          streamResults: Array.isArray(object === null || object === void 0 ? void 0 : object.streamResults) ? object.streamResults.map((e) => exports2.StreamInfo.fromJSON(e)) : [],
          fileResults: Array.isArray(object === null || object === void 0 ? void 0 : object.fileResults) ? object.fileResults.map((e) => exports2.FileInfo.fromJSON(e)) : [],
          segmentResults: Array.isArray(object === null || object === void 0 ? void 0 : object.segmentResults) ? object.segmentResults.map((e) => exports2.SegmentsInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.egressId !== void 0 && (obj.egressId = message.egressId);
        message.roomId !== void 0 && (obj.roomId = message.roomId);
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.status !== void 0 && (obj.status = egressStatusToJSON(message.status));
        message.startedAt !== void 0 && (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== void 0 && (obj.endedAt = Math.round(message.endedAt));
        message.updatedAt !== void 0 && (obj.updatedAt = Math.round(message.updatedAt));
        message.error !== void 0 && (obj.error = message.error);
        message.roomComposite !== void 0 && (obj.roomComposite = message.roomComposite ? exports2.RoomCompositeEgressRequest.toJSON(message.roomComposite) : void 0);
        message.trackComposite !== void 0 && (obj.trackComposite = message.trackComposite ? exports2.TrackCompositeEgressRequest.toJSON(message.trackComposite) : void 0);
        message.track !== void 0 && (obj.track = message.track ? exports2.TrackEgressRequest.toJSON(message.track) : void 0);
        message.web !== void 0 && (obj.web = message.web ? exports2.WebEgressRequest.toJSON(message.web) : void 0);
        message.stream !== void 0 && (obj.stream = message.stream ? exports2.StreamInfoList.toJSON(message.stream) : void 0);
        message.file !== void 0 && (obj.file = message.file ? exports2.FileInfo.toJSON(message.file) : void 0);
        message.segments !== void 0 && (obj.segments = message.segments ? exports2.SegmentsInfo.toJSON(message.segments) : void 0);
        if (message.streamResults) {
          obj.streamResults = message.streamResults.map((e) => e ? exports2.StreamInfo.toJSON(e) : void 0);
        } else {
          obj.streamResults = [];
        }
        if (message.fileResults) {
          obj.fileResults = message.fileResults.map((e) => e ? exports2.FileInfo.toJSON(e) : void 0);
        } else {
          obj.fileResults = [];
        }
        if (message.segmentResults) {
          obj.segmentResults = message.segmentResults.map((e) => e ? exports2.SegmentsInfo.toJSON(e) : void 0);
        } else {
          obj.segmentResults = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = createBaseEgressInfo();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        message.roomId = (_b = object.roomId) !== null && _b !== void 0 ? _b : "";
        message.roomName = (_c = object.roomName) !== null && _c !== void 0 ? _c : "";
        message.status = (_d = object.status) !== null && _d !== void 0 ? _d : 0;
        message.startedAt = (_e = object.startedAt) !== null && _e !== void 0 ? _e : 0;
        message.endedAt = (_f = object.endedAt) !== null && _f !== void 0 ? _f : 0;
        message.updatedAt = (_g = object.updatedAt) !== null && _g !== void 0 ? _g : 0;
        message.error = (_h = object.error) !== null && _h !== void 0 ? _h : "";
        message.roomComposite = object.roomComposite !== void 0 && object.roomComposite !== null ? exports2.RoomCompositeEgressRequest.fromPartial(object.roomComposite) : void 0;
        message.trackComposite = object.trackComposite !== void 0 && object.trackComposite !== null ? exports2.TrackCompositeEgressRequest.fromPartial(object.trackComposite) : void 0;
        message.track = object.track !== void 0 && object.track !== null ? exports2.TrackEgressRequest.fromPartial(object.track) : void 0;
        message.web = object.web !== void 0 && object.web !== null ? exports2.WebEgressRequest.fromPartial(object.web) : void 0;
        message.stream = object.stream !== void 0 && object.stream !== null ? exports2.StreamInfoList.fromPartial(object.stream) : void 0;
        message.file = object.file !== void 0 && object.file !== null ? exports2.FileInfo.fromPartial(object.file) : void 0;
        message.segments = object.segments !== void 0 && object.segments !== null ? exports2.SegmentsInfo.fromPartial(object.segments) : void 0;
        message.streamResults = ((_j = object.streamResults) === null || _j === void 0 ? void 0 : _j.map((e) => exports2.StreamInfo.fromPartial(e))) || [];
        message.fileResults = ((_k = object.fileResults) === null || _k === void 0 ? void 0 : _k.map((e) => exports2.FileInfo.fromPartial(e))) || [];
        message.segmentResults = ((_l = object.segmentResults) === null || _l === void 0 ? void 0 : _l.map((e) => exports2.SegmentsInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseStreamInfoList() {
      return { info: [] };
    }
    exports2.StreamInfoList = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.info !== void 0 && message.info.length !== 0) {
          for (const v of message.info) {
            exports2.StreamInfo.encode(v, writer.uint32(10).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStreamInfoList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info.push(exports2.StreamInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { info: Array.isArray(object === null || object === void 0 ? void 0 : object.info) ? object.info.map((e) => exports2.StreamInfo.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.info) {
          obj.info = message.info.map((e) => e ? exports2.StreamInfo.toJSON(e) : void 0);
        } else {
          obj.info = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseStreamInfoList();
        message.info = ((_a = object.info) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.StreamInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseStreamInfo() {
      return { url: "", startedAt: 0, endedAt: 0, duration: 0, status: 0, error: "" };
    }
    exports2.StreamInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.url !== void 0 && message.url !== "") {
          writer.uint32(10).string(message.url);
        }
        if (message.startedAt !== void 0 && message.startedAt !== 0) {
          writer.uint32(16).int64(message.startedAt);
        }
        if (message.endedAt !== void 0 && message.endedAt !== 0) {
          writer.uint32(24).int64(message.endedAt);
        }
        if (message.duration !== void 0 && message.duration !== 0) {
          writer.uint32(32).int64(message.duration);
        }
        if (message.status !== void 0 && message.status !== 0) {
          writer.uint32(40).int32(message.status);
        }
        if (message.error !== void 0 && message.error !== "") {
          writer.uint32(50).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStreamInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.url = reader.string();
              break;
            case 2:
              message.startedAt = longToNumber(reader.int64());
              break;
            case 3:
              message.endedAt = longToNumber(reader.int64());
              break;
            case 4:
              message.duration = longToNumber(reader.int64());
              break;
            case 5:
              message.status = reader.int32();
              break;
            case 6:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          url: isSet(object.url) ? String(object.url) : "",
          startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
          endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0,
          duration: isSet(object.duration) ? Number(object.duration) : 0,
          status: isSet(object.status) ? streamInfo_StatusFromJSON(object.status) : 0,
          error: isSet(object.error) ? String(object.error) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.url !== void 0 && (obj.url = message.url);
        message.startedAt !== void 0 && (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== void 0 && (obj.endedAt = Math.round(message.endedAt));
        message.duration !== void 0 && (obj.duration = Math.round(message.duration));
        message.status !== void 0 && (obj.status = streamInfo_StatusToJSON(message.status));
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseStreamInfo();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        message.startedAt = (_b = object.startedAt) !== null && _b !== void 0 ? _b : 0;
        message.endedAt = (_c = object.endedAt) !== null && _c !== void 0 ? _c : 0;
        message.duration = (_d = object.duration) !== null && _d !== void 0 ? _d : 0;
        message.status = (_e = object.status) !== null && _e !== void 0 ? _e : 0;
        message.error = (_f = object.error) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseFileInfo() {
      return { filename: "", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: "" };
    }
    exports2.FileInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.filename !== void 0 && message.filename !== "") {
          writer.uint32(10).string(message.filename);
        }
        if (message.startedAt !== void 0 && message.startedAt !== 0) {
          writer.uint32(16).int64(message.startedAt);
        }
        if (message.endedAt !== void 0 && message.endedAt !== 0) {
          writer.uint32(24).int64(message.endedAt);
        }
        if (message.duration !== void 0 && message.duration !== 0) {
          writer.uint32(48).int64(message.duration);
        }
        if (message.size !== void 0 && message.size !== 0) {
          writer.uint32(32).int64(message.size);
        }
        if (message.location !== void 0 && message.location !== "") {
          writer.uint32(42).string(message.location);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFileInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.filename = reader.string();
              break;
            case 2:
              message.startedAt = longToNumber(reader.int64());
              break;
            case 3:
              message.endedAt = longToNumber(reader.int64());
              break;
            case 6:
              message.duration = longToNumber(reader.int64());
              break;
            case 4:
              message.size = longToNumber(reader.int64());
              break;
            case 5:
              message.location = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          filename: isSet(object.filename) ? String(object.filename) : "",
          startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
          endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0,
          duration: isSet(object.duration) ? Number(object.duration) : 0,
          size: isSet(object.size) ? Number(object.size) : 0,
          location: isSet(object.location) ? String(object.location) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.filename !== void 0 && (obj.filename = message.filename);
        message.startedAt !== void 0 && (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== void 0 && (obj.endedAt = Math.round(message.endedAt));
        message.duration !== void 0 && (obj.duration = Math.round(message.duration));
        message.size !== void 0 && (obj.size = Math.round(message.size));
        message.location !== void 0 && (obj.location = message.location);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseFileInfo();
        message.filename = (_a = object.filename) !== null && _a !== void 0 ? _a : "";
        message.startedAt = (_b = object.startedAt) !== null && _b !== void 0 ? _b : 0;
        message.endedAt = (_c = object.endedAt) !== null && _c !== void 0 ? _c : 0;
        message.duration = (_d = object.duration) !== null && _d !== void 0 ? _d : 0;
        message.size = (_e = object.size) !== null && _e !== void 0 ? _e : 0;
        message.location = (_f = object.location) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseSegmentsInfo() {
      return { playlistName: "", duration: 0, size: 0, playlistLocation: "", segmentCount: 0, startedAt: 0, endedAt: 0 };
    }
    exports2.SegmentsInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.playlistName !== void 0 && message.playlistName !== "") {
          writer.uint32(10).string(message.playlistName);
        }
        if (message.duration !== void 0 && message.duration !== 0) {
          writer.uint32(16).int64(message.duration);
        }
        if (message.size !== void 0 && message.size !== 0) {
          writer.uint32(24).int64(message.size);
        }
        if (message.playlistLocation !== void 0 && message.playlistLocation !== "") {
          writer.uint32(34).string(message.playlistLocation);
        }
        if (message.segmentCount !== void 0 && message.segmentCount !== 0) {
          writer.uint32(40).int64(message.segmentCount);
        }
        if (message.startedAt !== void 0 && message.startedAt !== 0) {
          writer.uint32(48).int64(message.startedAt);
        }
        if (message.endedAt !== void 0 && message.endedAt !== 0) {
          writer.uint32(56).int64(message.endedAt);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSegmentsInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.playlistName = reader.string();
              break;
            case 2:
              message.duration = longToNumber(reader.int64());
              break;
            case 3:
              message.size = longToNumber(reader.int64());
              break;
            case 4:
              message.playlistLocation = reader.string();
              break;
            case 5:
              message.segmentCount = longToNumber(reader.int64());
              break;
            case 6:
              message.startedAt = longToNumber(reader.int64());
              break;
            case 7:
              message.endedAt = longToNumber(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          playlistName: isSet(object.playlistName) ? String(object.playlistName) : "",
          duration: isSet(object.duration) ? Number(object.duration) : 0,
          size: isSet(object.size) ? Number(object.size) : 0,
          playlistLocation: isSet(object.playlistLocation) ? String(object.playlistLocation) : "",
          segmentCount: isSet(object.segmentCount) ? Number(object.segmentCount) : 0,
          startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
          endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.playlistName !== void 0 && (obj.playlistName = message.playlistName);
        message.duration !== void 0 && (obj.duration = Math.round(message.duration));
        message.size !== void 0 && (obj.size = Math.round(message.size));
        message.playlistLocation !== void 0 && (obj.playlistLocation = message.playlistLocation);
        message.segmentCount !== void 0 && (obj.segmentCount = Math.round(message.segmentCount));
        message.startedAt !== void 0 && (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== void 0 && (obj.endedAt = Math.round(message.endedAt));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseSegmentsInfo();
        message.playlistName = (_a = object.playlistName) !== null && _a !== void 0 ? _a : "";
        message.duration = (_b = object.duration) !== null && _b !== void 0 ? _b : 0;
        message.size = (_c = object.size) !== null && _c !== void 0 ? _c : 0;
        message.playlistLocation = (_d = object.playlistLocation) !== null && _d !== void 0 ? _d : "";
        message.segmentCount = (_e = object.segmentCount) !== null && _e !== void 0 ? _e : 0;
        message.startedAt = (_f = object.startedAt) !== null && _f !== void 0 ? _f : 0;
        message.endedAt = (_g = object.endedAt) !== null && _g !== void 0 ? _g : 0;
        return message;
      }
    };
    function createBaseAutoTrackEgress() {
      return { filepath: "", disableManifest: false, s3: void 0, gcp: void 0, azure: void 0 };
    }
    exports2.AutoTrackEgress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.filepath !== void 0 && message.filepath !== "") {
          writer.uint32(10).string(message.filepath);
        }
        if (message.disableManifest === true) {
          writer.uint32(40).bool(message.disableManifest);
        }
        if (message.s3 !== void 0) {
          exports2.S3Upload.encode(message.s3, writer.uint32(18).fork()).ldelim();
        }
        if (message.gcp !== void 0) {
          exports2.GCPUpload.encode(message.gcp, writer.uint32(26).fork()).ldelim();
        }
        if (message.azure !== void 0) {
          exports2.AzureBlobUpload.encode(message.azure, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAutoTrackEgress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.filepath = reader.string();
              break;
            case 5:
              message.disableManifest = reader.bool();
              break;
            case 2:
              message.s3 = exports2.S3Upload.decode(reader, reader.uint32());
              break;
            case 3:
              message.gcp = exports2.GCPUpload.decode(reader, reader.uint32());
              break;
            case 4:
              message.azure = exports2.AzureBlobUpload.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          filepath: isSet(object.filepath) ? String(object.filepath) : "",
          disableManifest: isSet(object.disableManifest) ? Boolean(object.disableManifest) : false,
          s3: isSet(object.s3) ? exports2.S3Upload.fromJSON(object.s3) : void 0,
          gcp: isSet(object.gcp) ? exports2.GCPUpload.fromJSON(object.gcp) : void 0,
          azure: isSet(object.azure) ? exports2.AzureBlobUpload.fromJSON(object.azure) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.filepath !== void 0 && (obj.filepath = message.filepath);
        message.disableManifest !== void 0 && (obj.disableManifest = message.disableManifest);
        message.s3 !== void 0 && (obj.s3 = message.s3 ? exports2.S3Upload.toJSON(message.s3) : void 0);
        message.gcp !== void 0 && (obj.gcp = message.gcp ? exports2.GCPUpload.toJSON(message.gcp) : void 0);
        message.azure !== void 0 && (obj.azure = message.azure ? exports2.AzureBlobUpload.toJSON(message.azure) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseAutoTrackEgress();
        message.filepath = (_a = object.filepath) !== null && _a !== void 0 ? _a : "";
        message.disableManifest = (_b = object.disableManifest) !== null && _b !== void 0 ? _b : false;
        message.s3 = object.s3 !== void 0 && object.s3 !== null ? exports2.S3Upload.fromPartial(object.s3) : void 0;
        message.gcp = object.gcp !== void 0 && object.gcp !== null ? exports2.GCPUpload.fromPartial(object.gcp) : void 0;
        message.azure = object.azure !== void 0 && object.azure !== null ? exports2.AzureBlobUpload.fromPartial(object.azure) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function longToNumber(long) {
      if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
      }
      return long.toNumber();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/livekit-server-sdk/dist/ServiceBase.js
var require_ServiceBase = __commonJS({
  "node_modules/livekit-server-sdk/dist/ServiceBase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AccessToken_1 = require_AccessToken();
    var ServiceBase = class {
      /**
       * @param apiKey API Key.
       * @param secret API Secret.
       * @param ttl token TTL
       */
      constructor(apiKey, secret, ttl) {
        this.apiKey = apiKey;
        this.secret = secret;
        this.ttl = ttl || "10m";
      }
      authHeader(grant) {
        const at = new AccessToken_1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
        at.addGrant(grant);
        return {
          Authorization: `Bearer ${at.toJwt()}`
        };
      }
    };
    exports2.default = ServiceBase;
  }
});

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports2, module2) {
    "use strict";
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils.isPlainObject(thing) || utils.isArray(thing);
    }
    function removeBrackets(key) {
      return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils.isSpecCompliantForm(formData);
      if (!utils.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils.forEach(value, function each(el, key) {
          const result = !(utils.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var isStandardBrowserEnv = (() => {
      let product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    })();
    var isStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var platform = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      isStandardBrowserEnv,
      isStandardBrowserWebWorkerEnv,
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
        const obj = {};
        utils.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: platform.isNode ? "http" : "xhr",
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils.isObject(data);
        if (isObjectPayload && utils.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils.isString(value))
        return;
      if (utils.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils.forEach(this, (value, header) => {
          const key = utils.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform.isStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            const cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform.isStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else {
            requestHeaders.setContentType("multipart/form-data;", false);
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.isStandardBrowserEnv) {
          const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
            break;
          }
        }
        if (!adapter) {
          if (adapter === false) {
            throw new AxiosError(
              `Adapter ${nameOrAdapter} is not supported by the environment`,
              "ERR_NOT_SUPPORT"
            );
          }
          throw new Error(
            utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
          );
        }
        if (!utils.isFunction(adapter)) {
          throw new TypeError("adapter is not a function");
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge.call({ caseless }, target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var VERSION = "1.5.0";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports2, module2) {
    "use strict";
    var isObject = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module2.exports = (object, mapper, options) => {
      if (!isObject(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module2.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase;
    module2.exports.default = camelCase;
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports2, module2) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});

// node_modules/camelcase-keys/index.js
var require_camelcase_keys = __commonJS({
  "node_modules/camelcase-keys/index.js"(exports2, module2) {
    "use strict";
    var mapObj = require_map_obj();
    var camelCase = require_camelcase();
    var QuickLru = require_quick_lru();
    var has = (array, key) => array.some((x) => {
      if (typeof x === "string") {
        return x === key;
      }
      x.lastIndex = 0;
      return x.test(key);
    });
    var cache = new QuickLru({ maxSize: 1e5 });
    var isObject = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var camelCaseConvert = (input, options) => {
      if (!isObject(input)) {
        return input;
      }
      options = {
        deep: false,
        pascalCase: false,
        ...options
      };
      const { exclude, pascalCase, stopPaths, deep } = options;
      const stopPathsSet = new Set(stopPaths);
      const makeMapper = (parentPath) => (key, value) => {
        if (deep && isObject(value)) {
          const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
          if (!stopPathsSet.has(path)) {
            value = mapObj(value, makeMapper(path));
          }
        }
        if (!(exclude && has(exclude, key))) {
          const cacheKey = pascalCase ? `${key}_` : key;
          if (cache.has(cacheKey)) {
            key = cache.get(cacheKey);
          } else {
            const returnValue = camelCase(key, { pascalCase, locale: false });
            if (key.length < 100) {
              cache.set(cacheKey, returnValue);
            }
            key = returnValue;
          }
        }
        return [key, value];
      };
      return mapObj(input, makeMapper(void 0));
    };
    module2.exports = (input, options) => {
      if (Array.isArray(input)) {
        return Object.keys(input).map((key) => camelCaseConvert(input[key], options));
      }
      return camelCaseConvert(input, options);
    };
  }
});

// node_modules/livekit-server-sdk/dist/TwirpRPC.js
var require_TwirpRPC = __commonJS({
  "node_modules/livekit-server-sdk/dist/TwirpRPC.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwirpRpc = exports2.livekitPackage = void 0;
    var axios_1 = __importDefault(require_axios());
    var camelcase_keys_1 = __importDefault(require_camelcase_keys());
    var defaultPrefix = "/twirp";
    exports2.livekitPackage = "livekit";
    var TwirpRpc = class {
      constructor(host, pkg, prefix) {
        if (host.startsWith("ws")) {
          host = host.replace("ws", "http");
        }
        this.host = host;
        this.pkg = pkg;
        this.prefix = prefix || defaultPrefix;
        this.instance = axios_1.default.create({
          baseURL: host
        });
      }
      request(service, method, data, headers) {
        return new Promise((resolve, reject) => {
          const path = `${this.prefix}/${this.pkg}.${service}/${method}`;
          this.instance.post(path, data, { headers }).then((res) => {
            resolve(camelcase_keys_1.default(res.data, { deep: true }));
          }).catch(reject);
        });
      }
    };
    exports2.TwirpRpc = TwirpRpc;
  }
});

// node_modules/livekit-server-sdk/dist/EgressClient.js
var require_EgressClient = __commonJS({
  "node_modules/livekit-server-sdk/dist/EgressClient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EgressClient = void 0;
    var livekit_egress_1 = require_livekit_egress();
    var ServiceBase_1 = __importDefault(require_ServiceBase());
    var TwirpRPC_1 = require_TwirpRPC();
    var svc = "Egress";
    var EgressClient = class extends ServiceBase_1.default {
      /**
       * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
       * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
       * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
       */
      constructor(host, apiKey, secret) {
        super(apiKey, secret);
        this.rpc = new TwirpRPC_1.TwirpRpc(host, TwirpRPC_1.livekitPackage);
      }
      startRoomCompositeEgress(roomName, output, optsOrLayout, options, audioOnly, videoOnly, customBaseUrl) {
        return __awaiter(this, void 0, void 0, function* () {
          let layout;
          if (optsOrLayout !== void 0) {
            if (typeof optsOrLayout === "string") {
              layout = optsOrLayout;
            } else {
              const opts = optsOrLayout;
              layout = opts.layout;
              options = opts.encodingOptions;
              audioOnly = opts.audioOnly;
              videoOnly = opts.videoOnly;
              customBaseUrl = opts.customBaseUrl;
            }
          }
          layout !== null && layout !== void 0 ? layout : layout = "";
          audioOnly !== null && audioOnly !== void 0 ? audioOnly : audioOnly = false;
          videoOnly !== null && videoOnly !== void 0 ? videoOnly : videoOnly = false;
          customBaseUrl !== null && customBaseUrl !== void 0 ? customBaseUrl : customBaseUrl = "";
          const { file, stream, segments, preset, advanced, fileOutputs, streamOutputs, segmentOutputs } = this.getOutputParams(output, options);
          const req = livekit_egress_1.RoomCompositeEgressRequest.toJSON({
            roomName,
            layout,
            audioOnly,
            videoOnly,
            customBaseUrl,
            file,
            stream,
            segments,
            preset,
            advanced,
            fileOutputs,
            streamOutputs,
            segmentOutputs
          });
          const data = yield this.rpc.request(svc, "StartRoomCompositeEgress", req, this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
      /**
       * @param url url
       * @param output file or stream output
       * @param opts WebOptions
       */
      startWebEgress(url, output, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const audioOnly = (opts === null || opts === void 0 ? void 0 : opts.audioOnly) || false;
          const videoOnly = (opts === null || opts === void 0 ? void 0 : opts.videoOnly) || false;
          const awaitStartSignal = (opts === null || opts === void 0 ? void 0 : opts.awaitStartSignal) || false;
          const { file, stream, segments, preset, advanced, fileOutputs, streamOutputs, segmentOutputs } = this.getOutputParams(output, opts === null || opts === void 0 ? void 0 : opts.encodingOptions);
          const req = livekit_egress_1.WebEgressRequest.toJSON({
            url,
            audioOnly,
            videoOnly,
            awaitStartSignal,
            file,
            stream,
            segments,
            preset,
            advanced,
            fileOutputs,
            streamOutputs,
            segmentOutputs
          });
          const data = yield this.rpc.request(svc, "StartWebEgress", req, this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
      startTrackCompositeEgress(roomName, output, optsOrAudioTrackId, videoTrackId, options) {
        return __awaiter(this, void 0, void 0, function* () {
          let audioTrackId;
          if (optsOrAudioTrackId !== void 0) {
            if (typeof optsOrAudioTrackId === "string") {
              audioTrackId = optsOrAudioTrackId;
            } else {
              const opts = optsOrAudioTrackId;
              audioTrackId = opts.audioTrackId;
              videoTrackId = opts.videoTrackId;
              options = opts.encodingOptions;
            }
          }
          audioTrackId !== null && audioTrackId !== void 0 ? audioTrackId : audioTrackId = "";
          videoTrackId !== null && videoTrackId !== void 0 ? videoTrackId : videoTrackId = "";
          const { file, stream, segments, preset, advanced, fileOutputs, streamOutputs, segmentOutputs } = this.getOutputParams(output, options);
          const req = livekit_egress_1.TrackCompositeEgressRequest.toJSON({
            roomName,
            audioTrackId,
            videoTrackId,
            file,
            stream,
            segments,
            preset,
            advanced,
            fileOutputs,
            streamOutputs,
            segmentOutputs
          });
          const data = yield this.rpc.request(svc, "StartTrackCompositeEgress", req, this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
      isEncodedOutputs(output) {
        return output.file !== void 0 || output.stream !== void 0 || output.segments !== void 0;
      }
      isEncodedFileOutput(output) {
        return output.filepath !== void 0 || output.fileType !== void 0;
      }
      isSegmentedFileOutput(output) {
        return output.filenamePrefix !== void 0 || output.playlistName !== void 0 || output.filenameSuffix !== void 0;
      }
      isStreamOutput(output) {
        return output.protocol !== void 0 || output.urls !== void 0;
      }
      getOutputParams(output, options) {
        let file;
        let fileOutputs;
        let stream;
        let streamOutputs;
        let segments;
        let segmentOutputs;
        let preset;
        let advanced;
        if (this.isEncodedOutputs(output)) {
          if (output.file !== void 0) {
            fileOutputs = [output.file];
          }
          if (output.stream !== void 0) {
            streamOutputs = [output.stream];
          }
          if (output.segments !== void 0) {
            segmentOutputs = [output.segments];
          }
        } else if (this.isEncodedFileOutput(output)) {
          file = output;
          fileOutputs = [file];
        } else if (this.isSegmentedFileOutput(output)) {
          segments = output;
          segmentOutputs = [segments];
        } else if (this.isStreamOutput(output)) {
          stream = output;
          streamOutputs = [stream];
        }
        if (options) {
          if (typeof options === "number") {
            preset = options;
          } else {
            advanced = options;
          }
        }
        return { file, stream, segments, preset, advanced, fileOutputs, streamOutputs, segmentOutputs };
      }
      /**
       * @param roomName room name
       * @param output file or websocket output
       * @param trackId track Id
       */
      startTrackEgress(roomName, output, trackId) {
        return __awaiter(this, void 0, void 0, function* () {
          let file;
          let websocketUrl;
          if (typeof output === "string") {
            websocketUrl = output;
          } else {
            file = output;
          }
          const req = livekit_egress_1.TrackEgressRequest.toJSON({
            roomName,
            trackId,
            file,
            websocketUrl
          });
          const data = yield this.rpc.request(svc, "StartTrackEgress", req, this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
      /**
       * @param egressId
       * @param layout
       */
      updateLayout(egressId, layout) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "UpdateLayout", livekit_egress_1.UpdateLayoutRequest.toJSON({ egressId, layout }), this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
      /**
       * @param egressId
       * @param addOutputUrls
       * @param removeOutputUrls
       */
      updateStream(egressId, addOutputUrls, removeOutputUrls) {
        return __awaiter(this, void 0, void 0, function* () {
          addOutputUrls !== null && addOutputUrls !== void 0 ? addOutputUrls : addOutputUrls = [];
          removeOutputUrls !== null && removeOutputUrls !== void 0 ? removeOutputUrls : removeOutputUrls = [];
          const data = yield this.rpc.request(svc, "UpdateStream", livekit_egress_1.UpdateStreamRequest.toJSON({ egressId, addOutputUrls, removeOutputUrls }), this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
      /**
       * @param roomName list egress for one room only
       */
      listEgress(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          let req = {};
          if (typeof options === "string") {
            req.roomName = options;
          } else if (options !== void 0) {
            req = options;
          }
          const data = yield this.rpc.request(svc, "ListEgress", livekit_egress_1.ListEgressRequest.toJSON(req), this.authHeader({ roomRecord: true }));
          return (_a = livekit_egress_1.ListEgressResponse.fromJSON(data).items) !== null && _a !== void 0 ? _a : [];
        });
      }
      /**
       * @param egressId
       */
      stopEgress(egressId) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "StopEgress", livekit_egress_1.StopEgressRequest.toJSON({ egressId }), this.authHeader({ roomRecord: true }));
          return livekit_egress_1.EgressInfo.fromJSON(data);
        });
      }
    };
    exports2.EgressClient = EgressClient;
  }
});

// node_modules/livekit-server-sdk/dist/proto/livekit_ingress.js
var require_livekit_ingress = __commonJS({
  "node_modules/livekit-server-sdk/dist/proto/livekit_ingress.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeleteIngressRequest = exports2.ListIngressResponse = exports2.ListIngressRequest = exports2.UpdateIngressRequest = exports2.InputAudioState = exports2.InputVideoState = exports2.IngressState = exports2.IngressInfo = exports2.IngressVideoEncodingOptions = exports2.IngressAudioEncodingOptions = exports2.IngressVideoOptions = exports2.IngressAudioOptions = exports2.CreateIngressRequest = exports2.ingressState_StatusToJSON = exports2.ingressState_StatusFromJSON = exports2.IngressState_Status = exports2.ingressVideoEncodingPresetToJSON = exports2.ingressVideoEncodingPresetFromJSON = exports2.IngressVideoEncodingPreset = exports2.ingressAudioEncodingPresetToJSON = exports2.ingressAudioEncodingPresetFromJSON = exports2.IngressAudioEncodingPreset = exports2.ingressInputToJSON = exports2.ingressInputFromJSON = exports2.IngressInput = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_umd());
    var minimal_1 = __importDefault(require_minimal2());
    var livekit_models_1 = require_livekit_models();
    exports2.protobufPackage = "livekit";
    var IngressInput;
    (function(IngressInput2) {
      IngressInput2[IngressInput2["RTMP_INPUT"] = 0] = "RTMP_INPUT";
      IngressInput2[IngressInput2["WHIP_INPUT"] = 1] = "WHIP_INPUT";
      IngressInput2[IngressInput2["URL_INPUT"] = 2] = "URL_INPUT";
      IngressInput2[IngressInput2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(IngressInput = exports2.IngressInput || (exports2.IngressInput = {}));
    function ingressInputFromJSON(object) {
      switch (object) {
        case 0:
        case "RTMP_INPUT":
          return IngressInput.RTMP_INPUT;
        case 1:
        case "WHIP_INPUT":
          return IngressInput.WHIP_INPUT;
        case 2:
        case "URL_INPUT":
          return IngressInput.URL_INPUT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return IngressInput.UNRECOGNIZED;
      }
    }
    exports2.ingressInputFromJSON = ingressInputFromJSON;
    function ingressInputToJSON(object) {
      switch (object) {
        case IngressInput.RTMP_INPUT:
          return "RTMP_INPUT";
        case IngressInput.WHIP_INPUT:
          return "WHIP_INPUT";
        case IngressInput.URL_INPUT:
          return "URL_INPUT";
        case IngressInput.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.ingressInputToJSON = ingressInputToJSON;
    var IngressAudioEncodingPreset;
    (function(IngressAudioEncodingPreset2) {
      IngressAudioEncodingPreset2[IngressAudioEncodingPreset2["OPUS_STEREO_96KBPS"] = 0] = "OPUS_STEREO_96KBPS";
      IngressAudioEncodingPreset2[IngressAudioEncodingPreset2["OPUS_MONO_64KBS"] = 1] = "OPUS_MONO_64KBS";
      IngressAudioEncodingPreset2[IngressAudioEncodingPreset2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(IngressAudioEncodingPreset = exports2.IngressAudioEncodingPreset || (exports2.IngressAudioEncodingPreset = {}));
    function ingressAudioEncodingPresetFromJSON(object) {
      switch (object) {
        case 0:
        case "OPUS_STEREO_96KBPS":
          return IngressAudioEncodingPreset.OPUS_STEREO_96KBPS;
        case 1:
        case "OPUS_MONO_64KBS":
          return IngressAudioEncodingPreset.OPUS_MONO_64KBS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return IngressAudioEncodingPreset.UNRECOGNIZED;
      }
    }
    exports2.ingressAudioEncodingPresetFromJSON = ingressAudioEncodingPresetFromJSON;
    function ingressAudioEncodingPresetToJSON(object) {
      switch (object) {
        case IngressAudioEncodingPreset.OPUS_STEREO_96KBPS:
          return "OPUS_STEREO_96KBPS";
        case IngressAudioEncodingPreset.OPUS_MONO_64KBS:
          return "OPUS_MONO_64KBS";
        case IngressAudioEncodingPreset.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.ingressAudioEncodingPresetToJSON = ingressAudioEncodingPresetToJSON;
    var IngressVideoEncodingPreset;
    (function(IngressVideoEncodingPreset2) {
      IngressVideoEncodingPreset2[IngressVideoEncodingPreset2["H264_720P_30FPS_3_LAYERS"] = 0] = "H264_720P_30FPS_3_LAYERS";
      IngressVideoEncodingPreset2[IngressVideoEncodingPreset2["H264_1080P_30FPS_3_LAYERS"] = 1] = "H264_1080P_30FPS_3_LAYERS";
      IngressVideoEncodingPreset2[IngressVideoEncodingPreset2["H264_540P_25FPS_2_LAYERS"] = 2] = "H264_540P_25FPS_2_LAYERS";
      IngressVideoEncodingPreset2[IngressVideoEncodingPreset2["H264_720P_30FPS_1_LAYER"] = 3] = "H264_720P_30FPS_1_LAYER";
      IngressVideoEncodingPreset2[IngressVideoEncodingPreset2["H264_1080P_30FPS_1_LAYER"] = 4] = "H264_1080P_30FPS_1_LAYER";
      IngressVideoEncodingPreset2[IngressVideoEncodingPreset2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(IngressVideoEncodingPreset = exports2.IngressVideoEncodingPreset || (exports2.IngressVideoEncodingPreset = {}));
    function ingressVideoEncodingPresetFromJSON(object) {
      switch (object) {
        case 0:
        case "H264_720P_30FPS_3_LAYERS":
          return IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS;
        case 1:
        case "H264_1080P_30FPS_3_LAYERS":
          return IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS;
        case 2:
        case "H264_540P_25FPS_2_LAYERS":
          return IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS;
        case 3:
        case "H264_720P_30FPS_1_LAYER":
          return IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER;
        case 4:
        case "H264_1080P_30FPS_1_LAYER":
          return IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return IngressVideoEncodingPreset.UNRECOGNIZED;
      }
    }
    exports2.ingressVideoEncodingPresetFromJSON = ingressVideoEncodingPresetFromJSON;
    function ingressVideoEncodingPresetToJSON(object) {
      switch (object) {
        case IngressVideoEncodingPreset.H264_720P_30FPS_3_LAYERS:
          return "H264_720P_30FPS_3_LAYERS";
        case IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS:
          return "H264_1080P_30FPS_3_LAYERS";
        case IngressVideoEncodingPreset.H264_540P_25FPS_2_LAYERS:
          return "H264_540P_25FPS_2_LAYERS";
        case IngressVideoEncodingPreset.H264_720P_30FPS_1_LAYER:
          return "H264_720P_30FPS_1_LAYER";
        case IngressVideoEncodingPreset.H264_1080P_30FPS_1_LAYER:
          return "H264_1080P_30FPS_1_LAYER";
        case IngressVideoEncodingPreset.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.ingressVideoEncodingPresetToJSON = ingressVideoEncodingPresetToJSON;
    var IngressState_Status;
    (function(IngressState_Status2) {
      IngressState_Status2[IngressState_Status2["ENDPOINT_INACTIVE"] = 0] = "ENDPOINT_INACTIVE";
      IngressState_Status2[IngressState_Status2["ENDPOINT_BUFFERING"] = 1] = "ENDPOINT_BUFFERING";
      IngressState_Status2[IngressState_Status2["ENDPOINT_PUBLISHING"] = 2] = "ENDPOINT_PUBLISHING";
      IngressState_Status2[IngressState_Status2["ENDPOINT_ERROR"] = 3] = "ENDPOINT_ERROR";
      IngressState_Status2[IngressState_Status2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(IngressState_Status = exports2.IngressState_Status || (exports2.IngressState_Status = {}));
    function ingressState_StatusFromJSON(object) {
      switch (object) {
        case 0:
        case "ENDPOINT_INACTIVE":
          return IngressState_Status.ENDPOINT_INACTIVE;
        case 1:
        case "ENDPOINT_BUFFERING":
          return IngressState_Status.ENDPOINT_BUFFERING;
        case 2:
        case "ENDPOINT_PUBLISHING":
          return IngressState_Status.ENDPOINT_PUBLISHING;
        case 3:
        case "ENDPOINT_ERROR":
          return IngressState_Status.ENDPOINT_ERROR;
        case -1:
        case "UNRECOGNIZED":
        default:
          return IngressState_Status.UNRECOGNIZED;
      }
    }
    exports2.ingressState_StatusFromJSON = ingressState_StatusFromJSON;
    function ingressState_StatusToJSON(object) {
      switch (object) {
        case IngressState_Status.ENDPOINT_INACTIVE:
          return "ENDPOINT_INACTIVE";
        case IngressState_Status.ENDPOINT_BUFFERING:
          return "ENDPOINT_BUFFERING";
        case IngressState_Status.ENDPOINT_PUBLISHING:
          return "ENDPOINT_PUBLISHING";
        case IngressState_Status.ENDPOINT_ERROR:
          return "ENDPOINT_ERROR";
        case IngressState_Status.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.ingressState_StatusToJSON = ingressState_StatusToJSON;
    function createBaseCreateIngressRequest() {
      return {
        inputType: 0,
        url: "",
        name: "",
        roomName: "",
        participantIdentity: "",
        participantName: "",
        bypassTranscoding: false,
        audio: void 0,
        video: void 0
      };
    }
    exports2.CreateIngressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inputType !== void 0 && message.inputType !== 0) {
          writer.uint32(8).int32(message.inputType);
        }
        if (message.url !== void 0 && message.url !== "") {
          writer.uint32(74).string(message.url);
        }
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(26).string(message.roomName);
        }
        if (message.participantIdentity !== void 0 && message.participantIdentity !== "") {
          writer.uint32(34).string(message.participantIdentity);
        }
        if (message.participantName !== void 0 && message.participantName !== "") {
          writer.uint32(42).string(message.participantName);
        }
        if (message.bypassTranscoding === true) {
          writer.uint32(64).bool(message.bypassTranscoding);
        }
        if (message.audio !== void 0) {
          exports2.IngressAudioOptions.encode(message.audio, writer.uint32(50).fork()).ldelim();
        }
        if (message.video !== void 0) {
          exports2.IngressVideoOptions.encode(message.video, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCreateIngressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputType = reader.int32();
              break;
            case 9:
              message.url = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.roomName = reader.string();
              break;
            case 4:
              message.participantIdentity = reader.string();
              break;
            case 5:
              message.participantName = reader.string();
              break;
            case 8:
              message.bypassTranscoding = reader.bool();
              break;
            case 6:
              message.audio = exports2.IngressAudioOptions.decode(reader, reader.uint32());
              break;
            case 7:
              message.video = exports2.IngressVideoOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          inputType: isSet(object.inputType) ? ingressInputFromJSON(object.inputType) : 0,
          url: isSet(object.url) ? String(object.url) : "",
          name: isSet(object.name) ? String(object.name) : "",
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          participantIdentity: isSet(object.participantIdentity) ? String(object.participantIdentity) : "",
          participantName: isSet(object.participantName) ? String(object.participantName) : "",
          bypassTranscoding: isSet(object.bypassTranscoding) ? Boolean(object.bypassTranscoding) : false,
          audio: isSet(object.audio) ? exports2.IngressAudioOptions.fromJSON(object.audio) : void 0,
          video: isSet(object.video) ? exports2.IngressVideoOptions.fromJSON(object.video) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.inputType !== void 0 && (obj.inputType = ingressInputToJSON(message.inputType));
        message.url !== void 0 && (obj.url = message.url);
        message.name !== void 0 && (obj.name = message.name);
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.participantIdentity !== void 0 && (obj.participantIdentity = message.participantIdentity);
        message.participantName !== void 0 && (obj.participantName = message.participantName);
        message.bypassTranscoding !== void 0 && (obj.bypassTranscoding = message.bypassTranscoding);
        message.audio !== void 0 && (obj.audio = message.audio ? exports2.IngressAudioOptions.toJSON(message.audio) : void 0);
        message.video !== void 0 && (obj.video = message.video ? exports2.IngressVideoOptions.toJSON(message.video) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseCreateIngressRequest();
        message.inputType = (_a = object.inputType) !== null && _a !== void 0 ? _a : 0;
        message.url = (_b = object.url) !== null && _b !== void 0 ? _b : "";
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
        message.roomName = (_d = object.roomName) !== null && _d !== void 0 ? _d : "";
        message.participantIdentity = (_e = object.participantIdentity) !== null && _e !== void 0 ? _e : "";
        message.participantName = (_f = object.participantName) !== null && _f !== void 0 ? _f : "";
        message.bypassTranscoding = (_g = object.bypassTranscoding) !== null && _g !== void 0 ? _g : false;
        message.audio = object.audio !== void 0 && object.audio !== null ? exports2.IngressAudioOptions.fromPartial(object.audio) : void 0;
        message.video = object.video !== void 0 && object.video !== null ? exports2.IngressVideoOptions.fromPartial(object.video) : void 0;
        return message;
      }
    };
    function createBaseIngressAudioOptions() {
      return { name: "", source: 0, preset: void 0, options: void 0 };
    }
    exports2.IngressAudioOptions = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.source !== void 0 && message.source !== 0) {
          writer.uint32(16).int32(message.source);
        }
        if (message.preset !== void 0) {
          writer.uint32(24).int32(message.preset);
        }
        if (message.options !== void 0) {
          exports2.IngressAudioEncodingOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIngressAudioOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.source = reader.int32();
              break;
            case 3:
              message.preset = reader.int32();
              break;
            case 4:
              message.options = exports2.IngressAudioEncodingOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet(object.name) ? String(object.name) : "",
          source: isSet(object.source) ? livekit_models_1.trackSourceFromJSON(object.source) : 0,
          preset: isSet(object.preset) ? ingressAudioEncodingPresetFromJSON(object.preset) : void 0,
          options: isSet(object.options) ? exports2.IngressAudioEncodingOptions.fromJSON(object.options) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.source !== void 0 && (obj.source = livekit_models_1.trackSourceToJSON(message.source));
        message.preset !== void 0 && (obj.preset = message.preset !== void 0 ? ingressAudioEncodingPresetToJSON(message.preset) : void 0);
        message.options !== void 0 && (obj.options = message.options ? exports2.IngressAudioEncodingOptions.toJSON(message.options) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseIngressAudioOptions();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.source = (_b = object.source) !== null && _b !== void 0 ? _b : 0;
        message.preset = (_c = object.preset) !== null && _c !== void 0 ? _c : void 0;
        message.options = object.options !== void 0 && object.options !== null ? exports2.IngressAudioEncodingOptions.fromPartial(object.options) : void 0;
        return message;
      }
    };
    function createBaseIngressVideoOptions() {
      return { name: "", source: 0, preset: void 0, options: void 0 };
    }
    exports2.IngressVideoOptions = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.source !== void 0 && message.source !== 0) {
          writer.uint32(16).int32(message.source);
        }
        if (message.preset !== void 0) {
          writer.uint32(24).int32(message.preset);
        }
        if (message.options !== void 0) {
          exports2.IngressVideoEncodingOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIngressVideoOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.source = reader.int32();
              break;
            case 3:
              message.preset = reader.int32();
              break;
            case 4:
              message.options = exports2.IngressVideoEncodingOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet(object.name) ? String(object.name) : "",
          source: isSet(object.source) ? livekit_models_1.trackSourceFromJSON(object.source) : 0,
          preset: isSet(object.preset) ? ingressVideoEncodingPresetFromJSON(object.preset) : void 0,
          options: isSet(object.options) ? exports2.IngressVideoEncodingOptions.fromJSON(object.options) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.source !== void 0 && (obj.source = livekit_models_1.trackSourceToJSON(message.source));
        message.preset !== void 0 && (obj.preset = message.preset !== void 0 ? ingressVideoEncodingPresetToJSON(message.preset) : void 0);
        message.options !== void 0 && (obj.options = message.options ? exports2.IngressVideoEncodingOptions.toJSON(message.options) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseIngressVideoOptions();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.source = (_b = object.source) !== null && _b !== void 0 ? _b : 0;
        message.preset = (_c = object.preset) !== null && _c !== void 0 ? _c : void 0;
        message.options = object.options !== void 0 && object.options !== null ? exports2.IngressVideoEncodingOptions.fromPartial(object.options) : void 0;
        return message;
      }
    };
    function createBaseIngressAudioEncodingOptions() {
      return { audioCodec: 0, bitrate: 0, disableDtx: false, channels: 0 };
    }
    exports2.IngressAudioEncodingOptions = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.audioCodec !== void 0 && message.audioCodec !== 0) {
          writer.uint32(8).int32(message.audioCodec);
        }
        if (message.bitrate !== void 0 && message.bitrate !== 0) {
          writer.uint32(16).uint32(message.bitrate);
        }
        if (message.disableDtx === true) {
          writer.uint32(24).bool(message.disableDtx);
        }
        if (message.channels !== void 0 && message.channels !== 0) {
          writer.uint32(32).uint32(message.channels);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIngressAudioEncodingOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.audioCodec = reader.int32();
              break;
            case 2:
              message.bitrate = reader.uint32();
              break;
            case 3:
              message.disableDtx = reader.bool();
              break;
            case 4:
              message.channels = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          audioCodec: isSet(object.audioCodec) ? livekit_models_1.audioCodecFromJSON(object.audioCodec) : 0,
          bitrate: isSet(object.bitrate) ? Number(object.bitrate) : 0,
          disableDtx: isSet(object.disableDtx) ? Boolean(object.disableDtx) : false,
          channels: isSet(object.channels) ? Number(object.channels) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.audioCodec !== void 0 && (obj.audioCodec = livekit_models_1.audioCodecToJSON(message.audioCodec));
        message.bitrate !== void 0 && (obj.bitrate = Math.round(message.bitrate));
        message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
        message.channels !== void 0 && (obj.channels = Math.round(message.channels));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseIngressAudioEncodingOptions();
        message.audioCodec = (_a = object.audioCodec) !== null && _a !== void 0 ? _a : 0;
        message.bitrate = (_b = object.bitrate) !== null && _b !== void 0 ? _b : 0;
        message.disableDtx = (_c = object.disableDtx) !== null && _c !== void 0 ? _c : false;
        message.channels = (_d = object.channels) !== null && _d !== void 0 ? _d : 0;
        return message;
      }
    };
    function createBaseIngressVideoEncodingOptions() {
      return { videoCodec: 0, frameRate: 0, layers: [] };
    }
    exports2.IngressVideoEncodingOptions = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.videoCodec !== void 0 && message.videoCodec !== 0) {
          writer.uint32(8).int32(message.videoCodec);
        }
        if (message.frameRate !== void 0 && message.frameRate !== 0) {
          writer.uint32(17).double(message.frameRate);
        }
        if (message.layers !== void 0 && message.layers.length !== 0) {
          for (const v of message.layers) {
            livekit_models_1.VideoLayer.encode(v, writer.uint32(26).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIngressVideoEncodingOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.videoCodec = reader.int32();
              break;
            case 2:
              message.frameRate = reader.double();
              break;
            case 3:
              message.layers.push(livekit_models_1.VideoLayer.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          videoCodec: isSet(object.videoCodec) ? livekit_models_1.videoCodecFromJSON(object.videoCodec) : 0,
          frameRate: isSet(object.frameRate) ? Number(object.frameRate) : 0,
          layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e) => livekit_models_1.VideoLayer.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.videoCodec !== void 0 && (obj.videoCodec = livekit_models_1.videoCodecToJSON(message.videoCodec));
        message.frameRate !== void 0 && (obj.frameRate = message.frameRate);
        if (message.layers) {
          obj.layers = message.layers.map((e) => e ? livekit_models_1.VideoLayer.toJSON(e) : void 0);
        } else {
          obj.layers = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseIngressVideoEncodingOptions();
        message.videoCodec = (_a = object.videoCodec) !== null && _a !== void 0 ? _a : 0;
        message.frameRate = (_b = object.frameRate) !== null && _b !== void 0 ? _b : 0;
        message.layers = ((_c = object.layers) === null || _c === void 0 ? void 0 : _c.map((e) => livekit_models_1.VideoLayer.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseIngressInfo() {
      return {
        ingressId: "",
        name: "",
        streamKey: "",
        url: "",
        inputType: 0,
        bypassTranscoding: false,
        audio: void 0,
        video: void 0,
        roomName: "",
        participantIdentity: "",
        participantName: "",
        reusable: false,
        state: void 0
      };
    }
    exports2.IngressInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ingressId !== void 0 && message.ingressId !== "") {
          writer.uint32(10).string(message.ingressId);
        }
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.streamKey !== void 0 && message.streamKey !== "") {
          writer.uint32(26).string(message.streamKey);
        }
        if (message.url !== void 0 && message.url !== "") {
          writer.uint32(34).string(message.url);
        }
        if (message.inputType !== void 0 && message.inputType !== 0) {
          writer.uint32(40).int32(message.inputType);
        }
        if (message.bypassTranscoding === true) {
          writer.uint32(104).bool(message.bypassTranscoding);
        }
        if (message.audio !== void 0) {
          exports2.IngressAudioOptions.encode(message.audio, writer.uint32(50).fork()).ldelim();
        }
        if (message.video !== void 0) {
          exports2.IngressVideoOptions.encode(message.video, writer.uint32(58).fork()).ldelim();
        }
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(66).string(message.roomName);
        }
        if (message.participantIdentity !== void 0 && message.participantIdentity !== "") {
          writer.uint32(74).string(message.participantIdentity);
        }
        if (message.participantName !== void 0 && message.participantName !== "") {
          writer.uint32(82).string(message.participantName);
        }
        if (message.reusable === true) {
          writer.uint32(88).bool(message.reusable);
        }
        if (message.state !== void 0) {
          exports2.IngressState.encode(message.state, writer.uint32(98).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIngressInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ingressId = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.streamKey = reader.string();
              break;
            case 4:
              message.url = reader.string();
              break;
            case 5:
              message.inputType = reader.int32();
              break;
            case 13:
              message.bypassTranscoding = reader.bool();
              break;
            case 6:
              message.audio = exports2.IngressAudioOptions.decode(reader, reader.uint32());
              break;
            case 7:
              message.video = exports2.IngressVideoOptions.decode(reader, reader.uint32());
              break;
            case 8:
              message.roomName = reader.string();
              break;
            case 9:
              message.participantIdentity = reader.string();
              break;
            case 10:
              message.participantName = reader.string();
              break;
            case 11:
              message.reusable = reader.bool();
              break;
            case 12:
              message.state = exports2.IngressState.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          ingressId: isSet(object.ingressId) ? String(object.ingressId) : "",
          name: isSet(object.name) ? String(object.name) : "",
          streamKey: isSet(object.streamKey) ? String(object.streamKey) : "",
          url: isSet(object.url) ? String(object.url) : "",
          inputType: isSet(object.inputType) ? ingressInputFromJSON(object.inputType) : 0,
          bypassTranscoding: isSet(object.bypassTranscoding) ? Boolean(object.bypassTranscoding) : false,
          audio: isSet(object.audio) ? exports2.IngressAudioOptions.fromJSON(object.audio) : void 0,
          video: isSet(object.video) ? exports2.IngressVideoOptions.fromJSON(object.video) : void 0,
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          participantIdentity: isSet(object.participantIdentity) ? String(object.participantIdentity) : "",
          participantName: isSet(object.participantName) ? String(object.participantName) : "",
          reusable: isSet(object.reusable) ? Boolean(object.reusable) : false,
          state: isSet(object.state) ? exports2.IngressState.fromJSON(object.state) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.ingressId !== void 0 && (obj.ingressId = message.ingressId);
        message.name !== void 0 && (obj.name = message.name);
        message.streamKey !== void 0 && (obj.streamKey = message.streamKey);
        message.url !== void 0 && (obj.url = message.url);
        message.inputType !== void 0 && (obj.inputType = ingressInputToJSON(message.inputType));
        message.bypassTranscoding !== void 0 && (obj.bypassTranscoding = message.bypassTranscoding);
        message.audio !== void 0 && (obj.audio = message.audio ? exports2.IngressAudioOptions.toJSON(message.audio) : void 0);
        message.video !== void 0 && (obj.video = message.video ? exports2.IngressVideoOptions.toJSON(message.video) : void 0);
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.participantIdentity !== void 0 && (obj.participantIdentity = message.participantIdentity);
        message.participantName !== void 0 && (obj.participantName = message.participantName);
        message.reusable !== void 0 && (obj.reusable = message.reusable);
        message.state !== void 0 && (obj.state = message.state ? exports2.IngressState.toJSON(message.state) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseIngressInfo();
        message.ingressId = (_a = object.ingressId) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.streamKey = (_c = object.streamKey) !== null && _c !== void 0 ? _c : "";
        message.url = (_d = object.url) !== null && _d !== void 0 ? _d : "";
        message.inputType = (_e = object.inputType) !== null && _e !== void 0 ? _e : 0;
        message.bypassTranscoding = (_f = object.bypassTranscoding) !== null && _f !== void 0 ? _f : false;
        message.audio = object.audio !== void 0 && object.audio !== null ? exports2.IngressAudioOptions.fromPartial(object.audio) : void 0;
        message.video = object.video !== void 0 && object.video !== null ? exports2.IngressVideoOptions.fromPartial(object.video) : void 0;
        message.roomName = (_g = object.roomName) !== null && _g !== void 0 ? _g : "";
        message.participantIdentity = (_h = object.participantIdentity) !== null && _h !== void 0 ? _h : "";
        message.participantName = (_j = object.participantName) !== null && _j !== void 0 ? _j : "";
        message.reusable = (_k = object.reusable) !== null && _k !== void 0 ? _k : false;
        message.state = object.state !== void 0 && object.state !== null ? exports2.IngressState.fromPartial(object.state) : void 0;
        return message;
      }
    };
    function createBaseIngressState() {
      return {
        status: 0,
        error: "",
        video: void 0,
        audio: void 0,
        roomId: "",
        startedAt: 0,
        endedAt: 0,
        resourceId: "",
        tracks: []
      };
    }
    exports2.IngressState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== void 0 && message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        if (message.error !== void 0 && message.error !== "") {
          writer.uint32(18).string(message.error);
        }
        if (message.video !== void 0) {
          exports2.InputVideoState.encode(message.video, writer.uint32(26).fork()).ldelim();
        }
        if (message.audio !== void 0) {
          exports2.InputAudioState.encode(message.audio, writer.uint32(34).fork()).ldelim();
        }
        if (message.roomId !== void 0 && message.roomId !== "") {
          writer.uint32(42).string(message.roomId);
        }
        if (message.startedAt !== void 0 && message.startedAt !== 0) {
          writer.uint32(56).int64(message.startedAt);
        }
        if (message.endedAt !== void 0 && message.endedAt !== 0) {
          writer.uint32(64).int64(message.endedAt);
        }
        if (message.resourceId !== void 0 && message.resourceId !== "") {
          writer.uint32(74).string(message.resourceId);
        }
        if (message.tracks !== void 0 && message.tracks.length !== 0) {
          for (const v of message.tracks) {
            livekit_models_1.TrackInfo.encode(v, writer.uint32(50).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIngressState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            case 2:
              message.error = reader.string();
              break;
            case 3:
              message.video = exports2.InputVideoState.decode(reader, reader.uint32());
              break;
            case 4:
              message.audio = exports2.InputAudioState.decode(reader, reader.uint32());
              break;
            case 5:
              message.roomId = reader.string();
              break;
            case 7:
              message.startedAt = longToNumber(reader.int64());
              break;
            case 8:
              message.endedAt = longToNumber(reader.int64());
              break;
            case 9:
              message.resourceId = reader.string();
              break;
            case 6:
              message.tracks.push(livekit_models_1.TrackInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          status: isSet(object.status) ? ingressState_StatusFromJSON(object.status) : 0,
          error: isSet(object.error) ? String(object.error) : "",
          video: isSet(object.video) ? exports2.InputVideoState.fromJSON(object.video) : void 0,
          audio: isSet(object.audio) ? exports2.InputAudioState.fromJSON(object.audio) : void 0,
          roomId: isSet(object.roomId) ? String(object.roomId) : "",
          startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
          endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0,
          resourceId: isSet(object.resourceId) ? String(object.resourceId) : "",
          tracks: Array.isArray(object === null || object === void 0 ? void 0 : object.tracks) ? object.tracks.map((e) => livekit_models_1.TrackInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = ingressState_StatusToJSON(message.status));
        message.error !== void 0 && (obj.error = message.error);
        message.video !== void 0 && (obj.video = message.video ? exports2.InputVideoState.toJSON(message.video) : void 0);
        message.audio !== void 0 && (obj.audio = message.audio ? exports2.InputAudioState.toJSON(message.audio) : void 0);
        message.roomId !== void 0 && (obj.roomId = message.roomId);
        message.startedAt !== void 0 && (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== void 0 && (obj.endedAt = Math.round(message.endedAt));
        message.resourceId !== void 0 && (obj.resourceId = message.resourceId);
        if (message.tracks) {
          obj.tracks = message.tracks.map((e) => e ? livekit_models_1.TrackInfo.toJSON(e) : void 0);
        } else {
          obj.tracks = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseIngressState();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : "";
        message.video = object.video !== void 0 && object.video !== null ? exports2.InputVideoState.fromPartial(object.video) : void 0;
        message.audio = object.audio !== void 0 && object.audio !== null ? exports2.InputAudioState.fromPartial(object.audio) : void 0;
        message.roomId = (_c = object.roomId) !== null && _c !== void 0 ? _c : "";
        message.startedAt = (_d = object.startedAt) !== null && _d !== void 0 ? _d : 0;
        message.endedAt = (_e = object.endedAt) !== null && _e !== void 0 ? _e : 0;
        message.resourceId = (_f = object.resourceId) !== null && _f !== void 0 ? _f : "";
        message.tracks = ((_g = object.tracks) === null || _g === void 0 ? void 0 : _g.map((e) => livekit_models_1.TrackInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseInputVideoState() {
      return { mimeType: "", averageBitrate: 0, width: 0, height: 0, framerate: 0 };
    }
    exports2.InputVideoState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mimeType !== void 0 && message.mimeType !== "") {
          writer.uint32(10).string(message.mimeType);
        }
        if (message.averageBitrate !== void 0 && message.averageBitrate !== 0) {
          writer.uint32(16).uint32(message.averageBitrate);
        }
        if (message.width !== void 0 && message.width !== 0) {
          writer.uint32(24).uint32(message.width);
        }
        if (message.height !== void 0 && message.height !== 0) {
          writer.uint32(32).uint32(message.height);
        }
        if (message.framerate !== void 0 && message.framerate !== 0) {
          writer.uint32(41).double(message.framerate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInputVideoState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mimeType = reader.string();
              break;
            case 2:
              message.averageBitrate = reader.uint32();
              break;
            case 3:
              message.width = reader.uint32();
              break;
            case 4:
              message.height = reader.uint32();
              break;
            case 5:
              message.framerate = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mimeType: isSet(object.mimeType) ? String(object.mimeType) : "",
          averageBitrate: isSet(object.averageBitrate) ? Number(object.averageBitrate) : 0,
          width: isSet(object.width) ? Number(object.width) : 0,
          height: isSet(object.height) ? Number(object.height) : 0,
          framerate: isSet(object.framerate) ? Number(object.framerate) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
        message.averageBitrate !== void 0 && (obj.averageBitrate = Math.round(message.averageBitrate));
        message.width !== void 0 && (obj.width = Math.round(message.width));
        message.height !== void 0 && (obj.height = Math.round(message.height));
        message.framerate !== void 0 && (obj.framerate = message.framerate);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseInputVideoState();
        message.mimeType = (_a = object.mimeType) !== null && _a !== void 0 ? _a : "";
        message.averageBitrate = (_b = object.averageBitrate) !== null && _b !== void 0 ? _b : 0;
        message.width = (_c = object.width) !== null && _c !== void 0 ? _c : 0;
        message.height = (_d = object.height) !== null && _d !== void 0 ? _d : 0;
        message.framerate = (_e = object.framerate) !== null && _e !== void 0 ? _e : 0;
        return message;
      }
    };
    function createBaseInputAudioState() {
      return { mimeType: "", averageBitrate: 0, channels: 0, sampleRate: 0 };
    }
    exports2.InputAudioState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mimeType !== void 0 && message.mimeType !== "") {
          writer.uint32(10).string(message.mimeType);
        }
        if (message.averageBitrate !== void 0 && message.averageBitrate !== 0) {
          writer.uint32(16).uint32(message.averageBitrate);
        }
        if (message.channels !== void 0 && message.channels !== 0) {
          writer.uint32(24).uint32(message.channels);
        }
        if (message.sampleRate !== void 0 && message.sampleRate !== 0) {
          writer.uint32(32).uint32(message.sampleRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInputAudioState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mimeType = reader.string();
              break;
            case 2:
              message.averageBitrate = reader.uint32();
              break;
            case 3:
              message.channels = reader.uint32();
              break;
            case 4:
              message.sampleRate = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mimeType: isSet(object.mimeType) ? String(object.mimeType) : "",
          averageBitrate: isSet(object.averageBitrate) ? Number(object.averageBitrate) : 0,
          channels: isSet(object.channels) ? Number(object.channels) : 0,
          sampleRate: isSet(object.sampleRate) ? Number(object.sampleRate) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
        message.averageBitrate !== void 0 && (obj.averageBitrate = Math.round(message.averageBitrate));
        message.channels !== void 0 && (obj.channels = Math.round(message.channels));
        message.sampleRate !== void 0 && (obj.sampleRate = Math.round(message.sampleRate));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseInputAudioState();
        message.mimeType = (_a = object.mimeType) !== null && _a !== void 0 ? _a : "";
        message.averageBitrate = (_b = object.averageBitrate) !== null && _b !== void 0 ? _b : 0;
        message.channels = (_c = object.channels) !== null && _c !== void 0 ? _c : 0;
        message.sampleRate = (_d = object.sampleRate) !== null && _d !== void 0 ? _d : 0;
        return message;
      }
    };
    function createBaseUpdateIngressRequest() {
      return {
        ingressId: "",
        name: "",
        roomName: "",
        participantIdentity: "",
        participantName: "",
        bypassTranscoding: void 0,
        audio: void 0,
        video: void 0
      };
    }
    exports2.UpdateIngressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ingressId !== void 0 && message.ingressId !== "") {
          writer.uint32(10).string(message.ingressId);
        }
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(26).string(message.roomName);
        }
        if (message.participantIdentity !== void 0 && message.participantIdentity !== "") {
          writer.uint32(34).string(message.participantIdentity);
        }
        if (message.participantName !== void 0 && message.participantName !== "") {
          writer.uint32(42).string(message.participantName);
        }
        if (message.bypassTranscoding !== void 0) {
          writer.uint32(64).bool(message.bypassTranscoding);
        }
        if (message.audio !== void 0) {
          exports2.IngressAudioOptions.encode(message.audio, writer.uint32(50).fork()).ldelim();
        }
        if (message.video !== void 0) {
          exports2.IngressVideoOptions.encode(message.video, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateIngressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ingressId = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.roomName = reader.string();
              break;
            case 4:
              message.participantIdentity = reader.string();
              break;
            case 5:
              message.participantName = reader.string();
              break;
            case 8:
              message.bypassTranscoding = reader.bool();
              break;
            case 6:
              message.audio = exports2.IngressAudioOptions.decode(reader, reader.uint32());
              break;
            case 7:
              message.video = exports2.IngressVideoOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          ingressId: isSet(object.ingressId) ? String(object.ingressId) : "",
          name: isSet(object.name) ? String(object.name) : "",
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          participantIdentity: isSet(object.participantIdentity) ? String(object.participantIdentity) : "",
          participantName: isSet(object.participantName) ? String(object.participantName) : "",
          bypassTranscoding: isSet(object.bypassTranscoding) ? Boolean(object.bypassTranscoding) : void 0,
          audio: isSet(object.audio) ? exports2.IngressAudioOptions.fromJSON(object.audio) : void 0,
          video: isSet(object.video) ? exports2.IngressVideoOptions.fromJSON(object.video) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.ingressId !== void 0 && (obj.ingressId = message.ingressId);
        message.name !== void 0 && (obj.name = message.name);
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.participantIdentity !== void 0 && (obj.participantIdentity = message.participantIdentity);
        message.participantName !== void 0 && (obj.participantName = message.participantName);
        message.bypassTranscoding !== void 0 && (obj.bypassTranscoding = message.bypassTranscoding);
        message.audio !== void 0 && (obj.audio = message.audio ? exports2.IngressAudioOptions.toJSON(message.audio) : void 0);
        message.video !== void 0 && (obj.video = message.video ? exports2.IngressVideoOptions.toJSON(message.video) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseUpdateIngressRequest();
        message.ingressId = (_a = object.ingressId) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.roomName = (_c = object.roomName) !== null && _c !== void 0 ? _c : "";
        message.participantIdentity = (_d = object.participantIdentity) !== null && _d !== void 0 ? _d : "";
        message.participantName = (_e = object.participantName) !== null && _e !== void 0 ? _e : "";
        message.bypassTranscoding = (_f = object.bypassTranscoding) !== null && _f !== void 0 ? _f : void 0;
        message.audio = object.audio !== void 0 && object.audio !== null ? exports2.IngressAudioOptions.fromPartial(object.audio) : void 0;
        message.video = object.video !== void 0 && object.video !== null ? exports2.IngressVideoOptions.fromPartial(object.video) : void 0;
        return message;
      }
    };
    function createBaseListIngressRequest() {
      return { roomName: "", ingressId: "" };
    }
    exports2.ListIngressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomName !== void 0 && message.roomName !== "") {
          writer.uint32(10).string(message.roomName);
        }
        if (message.ingressId !== void 0 && message.ingressId !== "") {
          writer.uint32(18).string(message.ingressId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListIngressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.roomName = reader.string();
              break;
            case 2:
              message.ingressId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          roomName: isSet(object.roomName) ? String(object.roomName) : "",
          ingressId: isSet(object.ingressId) ? String(object.ingressId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.roomName !== void 0 && (obj.roomName = message.roomName);
        message.ingressId !== void 0 && (obj.ingressId = message.ingressId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseListIngressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.ingressId = (_b = object.ingressId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseListIngressResponse() {
      return { items: [] };
    }
    exports2.ListIngressResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.items !== void 0 && message.items.length !== 0) {
          for (const v of message.items) {
            exports2.IngressInfo.encode(v, writer.uint32(10).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListIngressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.items.push(exports2.IngressInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { items: Array.isArray(object === null || object === void 0 ? void 0 : object.items) ? object.items.map((e) => exports2.IngressInfo.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.items) {
          obj.items = message.items.map((e) => e ? exports2.IngressInfo.toJSON(e) : void 0);
        } else {
          obj.items = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseListIngressResponse();
        message.items = ((_a = object.items) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.IngressInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDeleteIngressRequest() {
      return { ingressId: "" };
    }
    exports2.DeleteIngressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ingressId !== void 0 && message.ingressId !== "") {
          writer.uint32(10).string(message.ingressId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeleteIngressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ingressId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { ingressId: isSet(object.ingressId) ? String(object.ingressId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.ingressId !== void 0 && (obj.ingressId = message.ingressId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDeleteIngressRequest();
        message.ingressId = (_a = object.ingressId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function longToNumber(long) {
      if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
      }
      return long.toNumber();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/livekit-server-sdk/dist/IngressClient.js
var require_IngressClient = __commonJS({
  "node_modules/livekit-server-sdk/dist/IngressClient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IngressClient = void 0;
    var livekit_ingress_1 = require_livekit_ingress();
    var ServiceBase_1 = __importDefault(require_ServiceBase());
    var TwirpRPC_1 = require_TwirpRPC();
    var svc = "Ingress";
    var IngressClient = class extends ServiceBase_1.default {
      /**
       * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
       * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
       * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
       */
      constructor(host, apiKey, secret) {
        super(apiKey, secret);
        this.rpc = new TwirpRPC_1.TwirpRpc(host, TwirpRPC_1.livekitPackage);
      }
      /**
       * @param inputType protocol for the ingress
       * @param opts CreateIngressOptions
       */
      createIngress(inputType, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          let name = "";
          let roomName = "";
          let participantName = "";
          let participantIdentity = "";
          let bypassTranscoding = false;
          let url = "";
          let audio;
          let video;
          if (opts !== void 0) {
            name = opts.name || "";
            roomName = opts.roomName || "";
            participantName = opts.participantName || "";
            participantIdentity = opts.participantIdentity || "";
            bypassTranscoding = opts.bypassTranscoding || false;
            url = opts.url || "";
            audio = opts.audio;
            video = opts.video;
          }
          const req = livekit_ingress_1.CreateIngressRequest.toJSON({
            inputType,
            name,
            roomName,
            participantIdentity,
            participantName,
            bypassTranscoding,
            url,
            audio,
            video
          });
          const data = yield this.rpc.request(svc, "CreateIngress", req, this.authHeader({ ingressAdmin: true }));
          return livekit_ingress_1.IngressInfo.fromJSON(data);
        });
      }
      /**
       * @param ingressId ID of the ingress to update
       * @param opts UpdateIngressOptions
       */
      updateIngress(ingressId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const name = opts.name || "";
          const roomName = opts.roomName || "";
          const participantName = opts.participantName || "";
          const participantIdentity = opts.participantIdentity || "";
          const { audio, video, bypassTranscoding } = opts;
          const req = livekit_ingress_1.UpdateIngressRequest.toJSON({
            ingressId,
            name,
            roomName,
            participantIdentity,
            participantName,
            bypassTranscoding,
            audio,
            video
          });
          const data = yield this.rpc.request(svc, "UpdateIngress", req, this.authHeader({ ingressAdmin: true }));
          return livekit_ingress_1.IngressInfo.fromJSON(data);
        });
      }
      /**
       * @param roomName list ingress for one room only
       */
      listIngress(roomName) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          roomName !== null && roomName !== void 0 ? roomName : roomName = "";
          const data = yield this.rpc.request(svc, "ListIngress", livekit_ingress_1.ListIngressRequest.toJSON({ roomName }), this.authHeader({ ingressAdmin: true }));
          return (_a = livekit_ingress_1.ListIngressResponse.fromJSON(data).items) !== null && _a !== void 0 ? _a : [];
        });
      }
      /**
       * @param ingressId ingress to delete
       */
      deleteIngress(ingressId) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "DeleteIngress", livekit_ingress_1.DeleteIngressRequest.toJSON({ ingressId }), this.authHeader({ ingressAdmin: true }));
          return livekit_ingress_1.IngressInfo.fromJSON(data);
        });
      }
    };
    exports2.IngressClient = IngressClient;
  }
});

// node_modules/livekit-server-sdk/dist/proto/livekit_room.js
var require_livekit_room = __commonJS({
  "node_modules/livekit-server-sdk/dist/proto/livekit_room.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateRoomMetadataRequest = exports2.SendDataResponse = exports2.SendDataRequest = exports2.UpdateSubscriptionsResponse = exports2.UpdateSubscriptionsRequest = exports2.UpdateParticipantRequest = exports2.MuteRoomTrackResponse = exports2.MuteRoomTrackRequest = exports2.RemoveParticipantResponse = exports2.RoomParticipantIdentity = exports2.ListParticipantsResponse = exports2.ListParticipantsRequest = exports2.DeleteRoomResponse = exports2.DeleteRoomRequest = exports2.ListRoomsResponse = exports2.ListRoomsRequest = exports2.RoomEgress = exports2.CreateRoomRequest = exports2.protobufPackage = void 0;
    var minimal_1 = __importDefault(require_minimal2());
    var livekit_egress_1 = require_livekit_egress();
    var livekit_models_1 = require_livekit_models();
    exports2.protobufPackage = "livekit";
    function createBaseCreateRoomRequest() {
      return {
        name: "",
        emptyTimeout: 0,
        maxParticipants: 0,
        nodeId: "",
        metadata: "",
        egress: void 0,
        minPlayoutDelay: 0
      };
    }
    exports2.CreateRoomRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.emptyTimeout !== void 0 && message.emptyTimeout !== 0) {
          writer.uint32(16).uint32(message.emptyTimeout);
        }
        if (message.maxParticipants !== void 0 && message.maxParticipants !== 0) {
          writer.uint32(24).uint32(message.maxParticipants);
        }
        if (message.nodeId !== void 0 && message.nodeId !== "") {
          writer.uint32(34).string(message.nodeId);
        }
        if (message.metadata !== void 0 && message.metadata !== "") {
          writer.uint32(42).string(message.metadata);
        }
        if (message.egress !== void 0) {
          exports2.RoomEgress.encode(message.egress, writer.uint32(50).fork()).ldelim();
        }
        if (message.minPlayoutDelay !== void 0 && message.minPlayoutDelay !== 0) {
          writer.uint32(56).uint32(message.minPlayoutDelay);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCreateRoomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.emptyTimeout = reader.uint32();
              break;
            case 3:
              message.maxParticipants = reader.uint32();
              break;
            case 4:
              message.nodeId = reader.string();
              break;
            case 5:
              message.metadata = reader.string();
              break;
            case 6:
              message.egress = exports2.RoomEgress.decode(reader, reader.uint32());
              break;
            case 7:
              message.minPlayoutDelay = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet(object.name) ? String(object.name) : "",
          emptyTimeout: isSet(object.emptyTimeout) ? Number(object.emptyTimeout) : 0,
          maxParticipants: isSet(object.maxParticipants) ? Number(object.maxParticipants) : 0,
          nodeId: isSet(object.nodeId) ? String(object.nodeId) : "",
          metadata: isSet(object.metadata) ? String(object.metadata) : "",
          egress: isSet(object.egress) ? exports2.RoomEgress.fromJSON(object.egress) : void 0,
          minPlayoutDelay: isSet(object.minPlayoutDelay) ? Number(object.minPlayoutDelay) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.emptyTimeout !== void 0 && (obj.emptyTimeout = Math.round(message.emptyTimeout));
        message.maxParticipants !== void 0 && (obj.maxParticipants = Math.round(message.maxParticipants));
        message.nodeId !== void 0 && (obj.nodeId = message.nodeId);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.egress !== void 0 && (obj.egress = message.egress ? exports2.RoomEgress.toJSON(message.egress) : void 0);
        message.minPlayoutDelay !== void 0 && (obj.minPlayoutDelay = Math.round(message.minPlayoutDelay));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseCreateRoomRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.emptyTimeout = (_b = object.emptyTimeout) !== null && _b !== void 0 ? _b : 0;
        message.maxParticipants = (_c = object.maxParticipants) !== null && _c !== void 0 ? _c : 0;
        message.nodeId = (_d = object.nodeId) !== null && _d !== void 0 ? _d : "";
        message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : "";
        message.egress = object.egress !== void 0 && object.egress !== null ? exports2.RoomEgress.fromPartial(object.egress) : void 0;
        message.minPlayoutDelay = (_f = object.minPlayoutDelay) !== null && _f !== void 0 ? _f : 0;
        return message;
      }
    };
    function createBaseRoomEgress() {
      return { room: void 0, tracks: void 0 };
    }
    exports2.RoomEgress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0) {
          livekit_egress_1.RoomCompositeEgressRequest.encode(message.room, writer.uint32(10).fork()).ldelim();
        }
        if (message.tracks !== void 0) {
          livekit_egress_1.AutoTrackEgress.encode(message.tracks, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRoomEgress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = livekit_egress_1.RoomCompositeEgressRequest.decode(reader, reader.uint32());
              break;
            case 2:
              message.tracks = livekit_egress_1.AutoTrackEgress.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? livekit_egress_1.RoomCompositeEgressRequest.fromJSON(object.room) : void 0,
          tracks: isSet(object.tracks) ? livekit_egress_1.AutoTrackEgress.fromJSON(object.tracks) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room ? livekit_egress_1.RoomCompositeEgressRequest.toJSON(message.room) : void 0);
        message.tracks !== void 0 && (obj.tracks = message.tracks ? livekit_egress_1.AutoTrackEgress.toJSON(message.tracks) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRoomEgress();
        message.room = object.room !== void 0 && object.room !== null ? livekit_egress_1.RoomCompositeEgressRequest.fromPartial(object.room) : void 0;
        message.tracks = object.tracks !== void 0 && object.tracks !== null ? livekit_egress_1.AutoTrackEgress.fromPartial(object.tracks) : void 0;
        return message;
      }
    };
    function createBaseListRoomsRequest() {
      return { names: [] };
    }
    exports2.ListRoomsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.names !== void 0 && message.names.length !== 0) {
          for (const v of message.names) {
            writer.uint32(10).string(v);
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListRoomsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.names.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { names: Array.isArray(object === null || object === void 0 ? void 0 : object.names) ? object.names.map((e) => String(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.names) {
          obj.names = message.names.map((e) => e);
        } else {
          obj.names = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseListRoomsRequest();
        message.names = ((_a = object.names) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseListRoomsResponse() {
      return { rooms: [] };
    }
    exports2.ListRoomsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rooms !== void 0 && message.rooms.length !== 0) {
          for (const v of message.rooms) {
            livekit_models_1.Room.encode(v, writer.uint32(10).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListRoomsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rooms.push(livekit_models_1.Room.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { rooms: Array.isArray(object === null || object === void 0 ? void 0 : object.rooms) ? object.rooms.map((e) => livekit_models_1.Room.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.rooms) {
          obj.rooms = message.rooms.map((e) => e ? livekit_models_1.Room.toJSON(e) : void 0);
        } else {
          obj.rooms = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseListRoomsResponse();
        message.rooms = ((_a = object.rooms) === null || _a === void 0 ? void 0 : _a.map((e) => livekit_models_1.Room.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDeleteRoomRequest() {
      return { room: "" };
    }
    exports2.DeleteRoomRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeleteRoomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { room: isSet(object.room) ? String(object.room) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDeleteRoomRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseDeleteRoomResponse() {
      return {};
    }
    exports2.DeleteRoomResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeleteRoomResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseDeleteRoomResponse();
        return message;
      }
    };
    function createBaseListParticipantsRequest() {
      return { room: "" };
    }
    exports2.ListParticipantsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListParticipantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { room: isSet(object.room) ? String(object.room) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseListParticipantsRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseListParticipantsResponse() {
      return { participants: [] };
    }
    exports2.ListParticipantsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participants !== void 0 && message.participants.length !== 0) {
          for (const v of message.participants) {
            livekit_models_1.ParticipantInfo.encode(v, writer.uint32(10).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListParticipantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.participants.push(livekit_models_1.ParticipantInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          participants: Array.isArray(object === null || object === void 0 ? void 0 : object.participants) ? object.participants.map((e) => livekit_models_1.ParticipantInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.participants) {
          obj.participants = message.participants.map((e) => e ? livekit_models_1.ParticipantInfo.toJSON(e) : void 0);
        } else {
          obj.participants = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseListParticipantsResponse();
        message.participants = ((_a = object.participants) === null || _a === void 0 ? void 0 : _a.map((e) => livekit_models_1.ParticipantInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseRoomParticipantIdentity() {
      return { room: "", identity: "" };
    }
    exports2.RoomParticipantIdentity = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        if (message.identity !== void 0 && message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRoomParticipantIdentity();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? String(object.room) : "",
          identity: isSet(object.identity) ? String(object.identity) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        message.identity !== void 0 && (obj.identity = message.identity);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRoomParticipantIdentity();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseRemoveParticipantResponse() {
      return {};
    }
    exports2.RemoveParticipantResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRemoveParticipantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRemoveParticipantResponse();
        return message;
      }
    };
    function createBaseMuteRoomTrackRequest() {
      return { room: "", identity: "", trackSid: "", muted: false };
    }
    exports2.MuteRoomTrackRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        if (message.identity !== void 0 && message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.trackSid !== void 0 && message.trackSid !== "") {
          writer.uint32(26).string(message.trackSid);
        }
        if (message.muted === true) {
          writer.uint32(32).bool(message.muted);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMuteRoomTrackRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.trackSid = reader.string();
              break;
            case 4:
              message.muted = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? String(object.room) : "",
          identity: isSet(object.identity) ? String(object.identity) : "",
          trackSid: isSet(object.trackSid) ? String(object.trackSid) : "",
          muted: isSet(object.muted) ? Boolean(object.muted) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
        message.muted !== void 0 && (obj.muted = message.muted);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMuteRoomTrackRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.trackSid = (_c = object.trackSid) !== null && _c !== void 0 ? _c : "";
        message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
        return message;
      }
    };
    function createBaseMuteRoomTrackResponse() {
      return { track: void 0 };
    }
    exports2.MuteRoomTrackResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.track !== void 0) {
          livekit_models_1.TrackInfo.encode(message.track, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMuteRoomTrackResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.track = livekit_models_1.TrackInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { track: isSet(object.track) ? livekit_models_1.TrackInfo.fromJSON(object.track) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.track !== void 0 && (obj.track = message.track ? livekit_models_1.TrackInfo.toJSON(message.track) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMuteRoomTrackResponse();
        message.track = object.track !== void 0 && object.track !== null ? livekit_models_1.TrackInfo.fromPartial(object.track) : void 0;
        return message;
      }
    };
    function createBaseUpdateParticipantRequest() {
      return { room: "", identity: "", metadata: "", permission: void 0, name: "" };
    }
    exports2.UpdateParticipantRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        if (message.identity !== void 0 && message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.metadata !== void 0 && message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.permission !== void 0) {
          livekit_models_1.ParticipantPermission.encode(message.permission, writer.uint32(34).fork()).ldelim();
        }
        if (message.name !== void 0 && message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateParticipantRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.permission = livekit_models_1.ParticipantPermission.decode(reader, reader.uint32());
              break;
            case 5:
              message.name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? String(object.room) : "",
          identity: isSet(object.identity) ? String(object.identity) : "",
          metadata: isSet(object.metadata) ? String(object.metadata) : "",
          permission: isSet(object.permission) ? livekit_models_1.ParticipantPermission.fromJSON(object.permission) : void 0,
          name: isSet(object.name) ? String(object.name) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.permission !== void 0 && (obj.permission = message.permission ? livekit_models_1.ParticipantPermission.toJSON(message.permission) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseUpdateParticipantRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : "";
        message.permission = object.permission !== void 0 && object.permission !== null ? livekit_models_1.ParticipantPermission.fromPartial(object.permission) : void 0;
        message.name = (_d = object.name) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseUpdateSubscriptionsRequest() {
      return { room: "", identity: "", trackSids: [], subscribe: false, participantTracks: [] };
    }
    exports2.UpdateSubscriptionsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        if (message.identity !== void 0 && message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.trackSids !== void 0 && message.trackSids.length !== 0) {
          for (const v of message.trackSids) {
            writer.uint32(26).string(v);
          }
        }
        if (message.subscribe === true) {
          writer.uint32(32).bool(message.subscribe);
        }
        if (message.participantTracks !== void 0 && message.participantTracks.length !== 0) {
          for (const v of message.participantTracks) {
            livekit_models_1.ParticipantTracks.encode(v, writer.uint32(42).fork()).ldelim();
          }
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.trackSids.push(reader.string());
              break;
            case 4:
              message.subscribe = reader.bool();
              break;
            case 5:
              message.participantTracks.push(livekit_models_1.ParticipantTracks.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? String(object.room) : "",
          identity: isSet(object.identity) ? String(object.identity) : "",
          trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e) => String(e)) : [],
          subscribe: isSet(object.subscribe) ? Boolean(object.subscribe) : false,
          participantTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.participantTracks) ? object.participantTracks.map((e) => livekit_models_1.ParticipantTracks.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        message.identity !== void 0 && (obj.identity = message.identity);
        if (message.trackSids) {
          obj.trackSids = message.trackSids.map((e) => e);
        } else {
          obj.trackSids = [];
        }
        message.subscribe !== void 0 && (obj.subscribe = message.subscribe);
        if (message.participantTracks) {
          obj.participantTracks = message.participantTracks.map((e) => e ? livekit_models_1.ParticipantTracks.toJSON(e) : void 0);
        } else {
          obj.participantTracks = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseUpdateSubscriptionsRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.trackSids = ((_c = object.trackSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.subscribe = (_d = object.subscribe) !== null && _d !== void 0 ? _d : false;
        message.participantTracks = ((_e = object.participantTracks) === null || _e === void 0 ? void 0 : _e.map((e) => livekit_models_1.ParticipantTracks.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseUpdateSubscriptionsResponse() {
      return {};
    }
    exports2.UpdateSubscriptionsResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseUpdateSubscriptionsResponse();
        return message;
      }
    };
    function createBaseSendDataRequest() {
      return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [], topic: void 0 };
    }
    exports2.SendDataRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        if (message.data !== void 0 && message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.kind !== void 0 && message.kind !== 0) {
          writer.uint32(24).int32(message.kind);
        }
        if (message.destinationSids !== void 0 && message.destinationSids.length !== 0) {
          for (const v of message.destinationSids) {
            writer.uint32(34).string(v);
          }
        }
        if (message.topic !== void 0) {
          writer.uint32(42).string(message.topic);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendDataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.kind = reader.int32();
              break;
            case 4:
              message.destinationSids.push(reader.string());
              break;
            case 5:
              message.topic = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? String(object.room) : "",
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          kind: isSet(object.kind) ? livekit_models_1.dataPacket_KindFromJSON(object.kind) : 0,
          destinationSids: Array.isArray(object === null || object === void 0 ? void 0 : object.destinationSids) ? object.destinationSids.map((e) => String(e)) : [],
          topic: isSet(object.topic) ? String(object.topic) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.kind !== void 0 && (obj.kind = livekit_models_1.dataPacket_KindToJSON(message.kind));
        if (message.destinationSids) {
          obj.destinationSids = message.destinationSids.map((e) => e);
        } else {
          obj.destinationSids = [];
        }
        message.topic !== void 0 && (obj.topic = message.topic);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseSendDataRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        message.destinationSids = ((_d = object.destinationSids) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.topic = (_e = object.topic) !== null && _e !== void 0 ? _e : void 0;
        return message;
      }
    };
    function createBaseSendDataResponse() {
      return {};
    }
    exports2.SendDataResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendDataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseSendDataResponse();
        return message;
      }
    };
    function createBaseUpdateRoomMetadataRequest() {
      return { room: "", metadata: "" };
    }
    exports2.UpdateRoomMetadataRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== void 0 && message.room !== "") {
          writer.uint32(10).string(message.room);
        }
        if (message.metadata !== void 0 && message.metadata !== "") {
          writer.uint32(18).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateRoomMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.room = reader.string();
              break;
            case 2:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          room: isSet(object.room) ? String(object.room) : "",
          metadata: isSet(object.metadata) ? String(object.metadata) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.room !== void 0 && (obj.room = message.room);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseUpdateRoomMetadataRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/livekit-server-sdk/dist/RoomServiceClient.js
var require_RoomServiceClient = __commonJS({
  "node_modules/livekit-server-sdk/dist/RoomServiceClient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RoomServiceClient = void 0;
    var livekit_models_1 = require_livekit_models();
    var livekit_room_1 = require_livekit_room();
    var ServiceBase_1 = __importDefault(require_ServiceBase());
    var TwirpRPC_1 = require_TwirpRPC();
    var svc = "RoomService";
    var RoomServiceClient = class extends ServiceBase_1.default {
      /**
       *
       * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
       * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
       * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
       */
      constructor(host, apiKey, secret) {
        super(apiKey, secret);
        this.rpc = new TwirpRPC_1.TwirpRpc(host, TwirpRPC_1.livekitPackage);
      }
      /**
       * Creates a new room. Explicit room creation is not required, since rooms will
       * be automatically created when the first participant joins. This method can be
       * used to customize room settings.
       * @param options
       */
      createRoom(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(options)), this.authHeader({ roomCreate: true }));
          return livekit_models_1.Room.fromJSON(data);
        });
      }
      /**
       * List active rooms
       * @param names when undefined or empty, list all rooms.
       *              otherwise returns rooms with matching names
       * @returns
       */
      listRooms(names) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: names !== null && names !== void 0 ? names : [] }), this.authHeader({ roomList: true }));
          const res = livekit_room_1.ListRoomsResponse.fromJSON(data);
          return (_a = res.rooms) !== null && _a !== void 0 ? _a : [];
        });
      }
      deleteRoom(room) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room }), this.authHeader({ roomCreate: true }));
        });
      }
      /**
       * Update metadata of a room
       * @param room name of the room
       * @param metadata the new metadata for the room
       */
      updateRoomMetadata(room, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room, metadata }), this.authHeader({ roomAdmin: true, room }));
          return livekit_models_1.Room.fromJSON(data);
        });
      }
      /**
       * List participants in a room
       * @param room name of the room
       */
      listParticipants(room) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room }), this.authHeader({ roomAdmin: true, room }));
          const res = livekit_room_1.ListParticipantsResponse.fromJSON(data);
          return (_a = res.participants) !== null && _a !== void 0 ? _a : [];
        });
      }
      /**
       * Get information on a specific participant, including the tracks that participant
       * has published
       * @param room name of the room
       * @param identity identity of the participant to return
       */
      getParticipant(room, identity) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room, identity }), this.authHeader({ roomAdmin: true, room }));
          return livekit_models_1.ParticipantInfo.fromJSON(data);
        });
      }
      /**
       * Removes a participant in the room. This will disconnect the participant
       * and will emit a Disconnected event for that participant.
       * Even after being removed, the participant can still re-join the room.
       * @param room
       * @param identity
       */
      removeParticipant(room, identity) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room, identity }), this.authHeader({ roomAdmin: true, room }));
        });
      }
      /**
       * Mutes a track that the participant has published.
       * @param room
       * @param identity
       * @param trackSid sid of the track to be muted
       * @param muted true to mute, false to unmute
       */
      mutePublishedTrack(room, identity, trackSid, muted) {
        return __awaiter(this, void 0, void 0, function* () {
          const req = livekit_room_1.MuteRoomTrackRequest.toJSON({
            room,
            identity,
            trackSid,
            muted
          });
          const data = yield this.rpc.request(svc, "MutePublishedTrack", req, this.authHeader({ roomAdmin: true, room }));
          const res = livekit_room_1.MuteRoomTrackResponse.fromJSON(data);
          return res.track;
        });
      }
      /**
       * Updates a participant's metadata or permissions
       * @param room
       * @param identity
       * @param metadata optional, metadata to update
       * @param permission optional, new permissions to assign to participant
       * @param name optional, new name for participant
       */
      updateParticipant(room, identity, metadata, permission, name) {
        return __awaiter(this, void 0, void 0, function* () {
          const req = {
            room,
            identity,
            metadata: metadata || "",
            name: name || ""
          };
          if (permission) {
            req.permission = livekit_models_1.ParticipantPermission.fromPartial(permission);
          }
          const data = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(req), this.authHeader({ roomAdmin: true, room }));
          return livekit_models_1.ParticipantInfo.fromJSON(data);
        });
      }
      /**
       * Updates a participant's subscription to tracks
       * @param room
       * @param identity
       * @param trackSids
       * @param subscribe true to subscribe, false to unsubscribe
       */
      updateSubscriptions(room, identity, trackSids, subscribe) {
        return __awaiter(this, void 0, void 0, function* () {
          const req = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
            room,
            identity,
            trackSids,
            subscribe,
            participantTracks: []
          });
          yield this.rpc.request(svc, "UpdateSubscriptions", req, this.authHeader({ roomAdmin: true, room }));
        });
      }
      sendData(room, data, kind, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const destinationSids = Array.isArray(options) ? options : options.destinationSids;
          const topic = Array.isArray(options) ? void 0 : options.topic;
          const req = livekit_room_1.SendDataRequest.toJSON({
            room,
            data,
            kind,
            destinationSids: destinationSids !== null && destinationSids !== void 0 ? destinationSids : [],
            topic
          });
          yield this.rpc.request(svc, "SendData", req, this.authHeader({ roomAdmin: true, room }));
        });
      }
    };
    exports2.RoomServiceClient = RoomServiceClient;
  }
});

// node_modules/livekit-server-sdk/dist/proto/livekit_webhook.js
var require_livekit_webhook = __commonJS({
  "node_modules/livekit-server-sdk/dist/proto/livekit_webhook.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebhookEvent = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_umd());
    var minimal_1 = __importDefault(require_minimal2());
    var livekit_egress_1 = require_livekit_egress();
    var livekit_ingress_1 = require_livekit_ingress();
    var livekit_models_1 = require_livekit_models();
    exports2.protobufPackage = "livekit";
    function createBaseWebhookEvent() {
      return {
        event: "",
        room: void 0,
        participant: void 0,
        egressInfo: void 0,
        ingressInfo: void 0,
        track: void 0,
        id: "",
        createdAt: 0,
        numDropped: 0
      };
    }
    exports2.WebhookEvent = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.event !== void 0 && message.event !== "") {
          writer.uint32(10).string(message.event);
        }
        if (message.room !== void 0) {
          livekit_models_1.Room.encode(message.room, writer.uint32(18).fork()).ldelim();
        }
        if (message.participant !== void 0) {
          livekit_models_1.ParticipantInfo.encode(message.participant, writer.uint32(26).fork()).ldelim();
        }
        if (message.egressInfo !== void 0) {
          livekit_egress_1.EgressInfo.encode(message.egressInfo, writer.uint32(74).fork()).ldelim();
        }
        if (message.ingressInfo !== void 0) {
          livekit_ingress_1.IngressInfo.encode(message.ingressInfo, writer.uint32(82).fork()).ldelim();
        }
        if (message.track !== void 0) {
          livekit_models_1.TrackInfo.encode(message.track, writer.uint32(66).fork()).ldelim();
        }
        if (message.id !== void 0 && message.id !== "") {
          writer.uint32(50).string(message.id);
        }
        if (message.createdAt !== void 0 && message.createdAt !== 0) {
          writer.uint32(56).int64(message.createdAt);
        }
        if (message.numDropped !== void 0 && message.numDropped !== 0) {
          writer.uint32(88).int32(message.numDropped);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebhookEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.event = reader.string();
              break;
            case 2:
              message.room = livekit_models_1.Room.decode(reader, reader.uint32());
              break;
            case 3:
              message.participant = livekit_models_1.ParticipantInfo.decode(reader, reader.uint32());
              break;
            case 9:
              message.egressInfo = livekit_egress_1.EgressInfo.decode(reader, reader.uint32());
              break;
            case 10:
              message.ingressInfo = livekit_ingress_1.IngressInfo.decode(reader, reader.uint32());
              break;
            case 8:
              message.track = livekit_models_1.TrackInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.id = reader.string();
              break;
            case 7:
              message.createdAt = longToNumber(reader.int64());
              break;
            case 11:
              message.numDropped = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          event: isSet(object.event) ? String(object.event) : "",
          room: isSet(object.room) ? livekit_models_1.Room.fromJSON(object.room) : void 0,
          participant: isSet(object.participant) ? livekit_models_1.ParticipantInfo.fromJSON(object.participant) : void 0,
          egressInfo: isSet(object.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(object.egressInfo) : void 0,
          ingressInfo: isSet(object.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(object.ingressInfo) : void 0,
          track: isSet(object.track) ? livekit_models_1.TrackInfo.fromJSON(object.track) : void 0,
          id: isSet(object.id) ? String(object.id) : "",
          createdAt: isSet(object.createdAt) ? Number(object.createdAt) : 0,
          numDropped: isSet(object.numDropped) ? Number(object.numDropped) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.event !== void 0 && (obj.event = message.event);
        message.room !== void 0 && (obj.room = message.room ? livekit_models_1.Room.toJSON(message.room) : void 0);
        message.participant !== void 0 && (obj.participant = message.participant ? livekit_models_1.ParticipantInfo.toJSON(message.participant) : void 0);
        message.egressInfo !== void 0 && (obj.egressInfo = message.egressInfo ? livekit_egress_1.EgressInfo.toJSON(message.egressInfo) : void 0);
        message.ingressInfo !== void 0 && (obj.ingressInfo = message.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(message.ingressInfo) : void 0);
        message.track !== void 0 && (obj.track = message.track ? livekit_models_1.TrackInfo.toJSON(message.track) : void 0);
        message.id !== void 0 && (obj.id = message.id);
        message.createdAt !== void 0 && (obj.createdAt = Math.round(message.createdAt));
        message.numDropped !== void 0 && (obj.numDropped = Math.round(message.numDropped));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseWebhookEvent();
        message.event = (_a = object.event) !== null && _a !== void 0 ? _a : "";
        message.room = object.room !== void 0 && object.room !== null ? livekit_models_1.Room.fromPartial(object.room) : void 0;
        message.participant = object.participant !== void 0 && object.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(object.participant) : void 0;
        message.egressInfo = object.egressInfo !== void 0 && object.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(object.egressInfo) : void 0;
        message.ingressInfo = object.ingressInfo !== void 0 && object.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(object.ingressInfo) : void 0;
        message.track = object.track !== void 0 && object.track !== null ? livekit_models_1.TrackInfo.fromPartial(object.track) : void 0;
        message.id = (_b = object.id) !== null && _b !== void 0 ? _b : "";
        message.createdAt = (_c = object.createdAt) !== null && _c !== void 0 ? _c : 0;
        message.numDropped = (_d = object.numDropped) !== null && _d !== void 0 ? _d : 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function longToNumber(long) {
      if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
      }
      return long.toNumber();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/livekit-server-sdk/dist/WebhookReceiver.js
var require_WebhookReceiver = __commonJS({
  "node_modules/livekit-server-sdk/dist/WebhookReceiver.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebhookReceiver = exports2.authorizeHeader = void 0;
    var crypto_1 = __importDefault(require_crypto());
    var AccessToken_1 = require_AccessToken();
    var livekit_webhook_1 = require_livekit_webhook();
    exports2.authorizeHeader = "Authorize";
    var WebhookReceiver = class {
      constructor(apiKey, apiSecret) {
        this.verifier = new AccessToken_1.TokenVerifier(apiKey, apiSecret);
      }
      /**
       *
       * @param body string of the posted body
       * @param authHeader `Authorization` header from the request
       * @param skipAuth true to skip auth validation
       * @returns
       */
      receive(body, authHeader, skipAuth = false) {
        if (!skipAuth) {
          if (!authHeader) {
            throw new Error("authorization header is empty");
          }
          const claims = this.verifier.verify(authHeader);
          const hash = crypto_1.default.createHash("sha256");
          hash.update(body);
          if (claims.sha256 !== hash.digest("base64")) {
            throw new Error("sha256 checksum of body does not match");
          }
        }
        return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(body));
      }
    };
    exports2.WebhookReceiver = WebhookReceiver;
  }
});

// node_modules/livekit-server-sdk/dist/grants.js
var require_grants = __commonJS({
  "node_modules/livekit-server-sdk/dist/grants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrackSource = void 0;
    var TrackSource;
    (function(TrackSource2) {
      TrackSource2["CAMERA"] = "camera";
      TrackSource2["MICROPHONE"] = "microphone";
      TrackSource2["SCREEN_SHARE"] = "screen_share";
      TrackSource2["SCREEN_SHARE_AUDIO"] = "screen_share_audio";
    })(TrackSource = exports2.TrackSource || (exports2.TrackSource = {}));
  }
});

// node_modules/livekit-server-sdk/dist/index.js
var require_dist = __commonJS({
  "node_modules/livekit-server-sdk/dist/index.js"(exports2) {
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrackType = exports2.TrackInfo = exports2.Room = exports2.ParticipantPermission = exports2.ParticipantInfo_State = exports2.ParticipantInfo = exports2.DataPacket_Kind = exports2.IngressVideoOptions = exports2.IngressVideoEncodingPreset = exports2.IngressVideoEncodingOptions = exports2.IngressState = exports2.IngressInput = exports2.IngressInfo = exports2.IngressAudioOptions = exports2.IngressAudioEncodingPreset = exports2.IngressAudioEncodingOptions = exports2.StreamProtocol = exports2.StreamOutput = exports2.SegmentedFileProtocol = exports2.SegmentedFileOutput = exports2.EncodingOptionsPreset = exports2.EncodingOptions = exports2.EncodedFileType = exports2.EncodedFileOutput = exports2.EgressInfo = exports2.DirectFileOutput = void 0;
    __exportStar(require_AccessToken(), exports2);
    __exportStar(require_EgressClient(), exports2);
    __exportStar(require_IngressClient(), exports2);
    __exportStar(require_RoomServiceClient(), exports2);
    __exportStar(require_WebhookReceiver(), exports2);
    __exportStar(require_grants(), exports2);
    var livekit_egress_1 = require_livekit_egress();
    Object.defineProperty(exports2, "DirectFileOutput", { enumerable: true, get: function() {
      return livekit_egress_1.DirectFileOutput;
    } });
    Object.defineProperty(exports2, "EgressInfo", { enumerable: true, get: function() {
      return livekit_egress_1.EgressInfo;
    } });
    Object.defineProperty(exports2, "EncodedFileOutput", { enumerable: true, get: function() {
      return livekit_egress_1.EncodedFileOutput;
    } });
    Object.defineProperty(exports2, "EncodedFileType", { enumerable: true, get: function() {
      return livekit_egress_1.EncodedFileType;
    } });
    Object.defineProperty(exports2, "EncodingOptions", { enumerable: true, get: function() {
      return livekit_egress_1.EncodingOptions;
    } });
    Object.defineProperty(exports2, "EncodingOptionsPreset", { enumerable: true, get: function() {
      return livekit_egress_1.EncodingOptionsPreset;
    } });
    Object.defineProperty(exports2, "SegmentedFileOutput", { enumerable: true, get: function() {
      return livekit_egress_1.SegmentedFileOutput;
    } });
    Object.defineProperty(exports2, "SegmentedFileProtocol", { enumerable: true, get: function() {
      return livekit_egress_1.SegmentedFileProtocol;
    } });
    Object.defineProperty(exports2, "StreamOutput", { enumerable: true, get: function() {
      return livekit_egress_1.StreamOutput;
    } });
    Object.defineProperty(exports2, "StreamProtocol", { enumerable: true, get: function() {
      return livekit_egress_1.StreamProtocol;
    } });
    var livekit_ingress_1 = require_livekit_ingress();
    Object.defineProperty(exports2, "IngressAudioEncodingOptions", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressAudioEncodingOptions;
    } });
    Object.defineProperty(exports2, "IngressAudioEncodingPreset", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressAudioEncodingPreset;
    } });
    Object.defineProperty(exports2, "IngressAudioOptions", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressAudioOptions;
    } });
    Object.defineProperty(exports2, "IngressInfo", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressInfo;
    } });
    Object.defineProperty(exports2, "IngressInput", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressInput;
    } });
    Object.defineProperty(exports2, "IngressState", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressState;
    } });
    Object.defineProperty(exports2, "IngressVideoEncodingOptions", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressVideoEncodingOptions;
    } });
    Object.defineProperty(exports2, "IngressVideoEncodingPreset", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressVideoEncodingPreset;
    } });
    Object.defineProperty(exports2, "IngressVideoOptions", { enumerable: true, get: function() {
      return livekit_ingress_1.IngressVideoOptions;
    } });
    var livekit_models_1 = require_livekit_models();
    Object.defineProperty(exports2, "DataPacket_Kind", { enumerable: true, get: function() {
      return livekit_models_1.DataPacket_Kind;
    } });
    Object.defineProperty(exports2, "ParticipantInfo", { enumerable: true, get: function() {
      return livekit_models_1.ParticipantInfo;
    } });
    Object.defineProperty(exports2, "ParticipantInfo_State", { enumerable: true, get: function() {
      return livekit_models_1.ParticipantInfo_State;
    } });
    Object.defineProperty(exports2, "ParticipantPermission", { enumerable: true, get: function() {
      return livekit_models_1.ParticipantPermission;
    } });
    Object.defineProperty(exports2, "Room", { enumerable: true, get: function() {
      return livekit_models_1.Room;
    } });
    Object.defineProperty(exports2, "TrackInfo", { enumerable: true, get: function() {
      return livekit_models_1.TrackInfo;
    } });
    Object.defineProperty(exports2, "TrackType", { enumerable: true, get: function() {
      return livekit_models_1.TrackType;
    } });
  }
});
export default require_dist();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

long/umd/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=livekit-server-sdk.js.map
